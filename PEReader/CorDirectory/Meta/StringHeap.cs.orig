using System;
using System.Collections.Generic;
<<<<<<< HEAD
using System.Text;
=======
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90

namespace AlphaOmega.Debug.CorDirectory.Meta
{
	/// <summary>String heap class</summary>
<<<<<<< HEAD
	public class StringHeap : StreamHeaderTyped<String>
	{
=======
	public class StringHeap : StreamHeader
	{
		private SortedList<Int32,String> _data;

>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Create instance of String heap class</summary>
		/// <param name="meta">MetaData directory</param>
		/// <param name="header">.NET stream header</param>
		/// <exception cref="T:InvalidOperationException">StringHeap class can only read String heap</exception>
		public StringHeap(MetaData meta, Cor.STREAM_HEADER header)
			: base(meta, header)
		{
			if(base.Header.Type != Cor.StreamHeaderType.String)
				throw new InvalidOperationException();
		}
<<<<<<< HEAD

		/// <summary>
		/// The .NET specification allows a string reference to point anywhere in the string heap, not just to thestart of a string.
		/// Therefore, it is possible (although probably not very useful) to create an assembly in which some strings overlap with each other.
		/// </summary>
		/// <param name="pointer">Pointer in the heap</param>
		/// <returns>Data by pointer</returns>
		protected override String GetDataByPointer(Int32 pointer)
		{
			SortedList<Int32, String> data = base.GetData();
			Int32 key = pointer;
			String nearestString = null;
			while(key >= 0 && !data.TryGetValue(key, out nearestString))
				key--;

			Int32 diff = pointer - key;

			//TODO: Here i can add found string to the SortedList<,>
			String result = nearestString.Substring(diff, nearestString.Length - diff);
			return result;
		}

		/// <summary>Binds the data form stream to string array</summary>
		protected override SortedList<Int32,String> DataBind()
		{
			SortedList<Int32, String> result = new SortedList<Int32, String>();

			Byte[] bytes = base.Bytes;
			Int32 ptr = 0;
=======
		/// <summary>Get string from string heap</summary>
		/// <param name="index">String index in the heap</param>
		/// <returns>String from heap</returns>
		public String this[Int32 index]
		{
			get
			{
				return this.Data[index];

				/*
				 * The .NET specification allows a string reference to point anywhere in the string heap, not just to thestart of a string. Therefore, it is possible (although probably not very useful) to create an assembly in which some strings overlap with each other. Such an assembly can be read by Asmex if the GetByOffset method of MDHeap is overridded in the MDStringHeap class thus:
				/*
				Int32 originalKey = key;
				String result = this.Data[key];

				while(result == null && key >= 0)
					result = this.Data[--key];// Locate the previous key (there's probably a more efficient way of doing this).

				if(originalKey != key)
				{// re-index into the string
					Int32 diff = originalKey - key;
					result = result.Substring(diff, result.Length - diff);
				}
				return result;*/
			}
		}
		/// <summary>All strings from heap</summary>
		public SortedList<Int32, String> Data
		{
			get
			{
				if(this._data == null)
					this._data = this.GetDataI();
				return this._data;
			}
		}
		private SortedList<Int32, String> GetDataI()
		{
			SortedList<Int32, String> result = new SortedList<Int32, String>();

			Int32 ptr = 0;
			Byte[] bytes = base.Bytes;
			String str = String.Empty;
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90

			for(Int32 loop = 0; loop < bytes.Length; loop++)
			{
				if(bytes[loop] == 0)
				{
<<<<<<< HEAD
					String str = Encoding.ASCII.GetString(bytes, ptr, loop - ptr);

					result.Add(ptr, str);
					ptr = loop + 1;
=======
					result.Add(ptr, str);
					ptr = loop + 1;
					str = String.Empty;
				} else
				{
					Char ch = (Char)bytes[loop];
					str += ch;
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
				}
			}
			return result;
		}
	}
}