using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.InteropServices;
using AlphaOmega.Debug.CorDirectory.Meta.Tables;
using AlphaOmega.Debug.NTDirectory;

namespace AlphaOmega.Debug.CorDirectory
{
	/// <summary>Managed resource table class</summary>
	[DefaultProperty("Header")]
	public class ResourceTable : CorDirectoryBase, IEnumerable<ResourceTableReader>
	{
<<<<<<< HEAD
		#region Fields
		private Cor.ResourceManagerHeader? _header;
		private Cor.ResourceSetHeader? _set;
		#endregion Fields

=======
		private Cor.ResourceManagerHeader? _header;
		private Cor.ResourceSetHeader? _set;
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Managed resource header</summary>
		public Cor.ResourceManagerHeader Header
		{
			get
			{
				if(this._header == null)
					this._header = base.Parent.Parent.Header.PtrToStructure<Cor.ResourceManagerHeader>(base.Directory.VirtualAddress);
				return this._header.Value;
			}
		}
<<<<<<< HEAD

=======
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Resource header</summary>
		/// <exception cref="T:InvalidOperationException">Managed resource header is invalid</exception>
		public Cor.ResourceSetHeader RuntimeHeader
		{
			get
			{
				if(this._set == null)
				{
					if(!this.Header.IsValid)
						throw new InvalidOperationException("Magic invalid");

					UInt32 offset = base.Directory.VirtualAddress + (UInt32)Marshal.SizeOf(typeof(Cor.ResourceManagerHeader))
						+ this.Header.SizeOfReaderType;
					this._set = base.Parent.Parent.Header.PtrToStructure<Cor.ResourceSetHeader>(offset);
				}
				return this._set.Value;
			}
		}
<<<<<<< HEAD

=======
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Create instance of managed resource class</summary>
		/// <param name="parent">NT directory</param>
		public ResourceTable(ComDescriptor parent)
			: base(parent, WinNT.COR20_DIRECTORY_ENTRY.Resources)
		{
		}
<<<<<<< HEAD

=======
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Get all metadata table rows that contains files in this directory</summary>
		/// <returns>ManifestResource table rows</returns>
		public IEnumerator<ResourceTableReader> GetEnumerator()
		{
			foreach(ManifestResourceRow row in base.Parent.MetaData.StreamTables.ManifestResource)
				if(row.FileInDirectory)
					yield return row.GetResourceReader();
<<<<<<< HEAD
		}

=======
				else throw new NotImplementedException();
		}
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
<<<<<<< HEAD

=======
>>>>>>> a19aeac02d80c25d8fd68cb439b59fc58b285e90
		/// <summary>Decode 7bit encoded Int</summary>
		/// <param name="offset">Ofsset from resource_manager header</param>
		/// <param name="value"></param>
		/// <param name="size"></param>
		private void DecodeInt(UInt32 offset, out UInt32 value, out UInt32 size)
		{//TODO: Остался от неуправляемого метода чтения ресурсов из файла
			Int32 a=0, b=0;
			UInt32 x = 0;
			while(true)
			{
				Byte c = base.Parent.Parent.Header.ReadBytes(offset++, 1)[0];
				a |= ((c & 0x7F) << (b & 0x1F));
				b += 7;

				x++;

				if((c & 0x80) == 0)
					break;
			}
			value = (UInt32)a;
			size = x;
		}
	}
}