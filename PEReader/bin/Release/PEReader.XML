<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PEReader</name>
    </assembly>
    <members>
        <member name="T:AlphaOmega.Debug.PEDirectory">
            <summary>NT Directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.PEDirectory.#ctor(AlphaOmega.Debug.IImageLoader)">
            <summary>Создание экземпляра класса с указанием пути к PE файлу</summary>
            <param name="loader">PE file loader</param>
        </member>
        <member name="M:AlphaOmega.Debug.PEDirectory.Dispose">
            <summary>Close loader</summary>
        </member>
        <member name="M:AlphaOmega.Debug.PEDirectory.Dispose(System.Boolean)">
            <summary>Dispose managed objects</summary>
            <param name="disposing">Dispose managed objects</param>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Header">
            <summary>PE/PE+ Headers</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Item(AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY)">
            <summary>Get directory from optional header</summary>
            <param name="entry">Directory entry type</param>
            <returns>Directory</returns>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Architecture">
            <summary>Architecture directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Export">
            <summary>Получить информацию о экспортируемых функциях в PE файле</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Import">
            <summary>Получить информацию о ипортируемых функциях PE файлом</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Debug">
            <summary>Получить информацию о зашитой информации для дебаггера</summary>
            <returns>Информация для дебаггера</returns>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Resource">
            <summary>Получить информацию по ресурсам</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.ComDescriptor">
            <summary>.NET Directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.LoadConfig">
            <summary>Load config directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Certificate">
            <summary>Certificate directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.BoundImport">
            <summary>Boundimport directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Relocations">
            <summary>Relocation directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.DelayImport">
            <summary>Delay import modules directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.GlobalPtr">
            <summary>Global pointer directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.ExceptionTable">
            <summary>Exception table directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Iat">
            <summary>Import Address Table directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEDirectory.Tls">
            <summary>Thread local storage directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NativeMethods">
            <summary>Win32 methods and helpers</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.BIT_SIZE_SHORT">
            <summary>The max number of bits in short </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.BIT_SIZE_INT">
            <summary>The max number of bits in int</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.BIT_SIZE_LONG">
            <summary>The max number of bits in long</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.ConvertTimeDateStamp(System.UInt32)">
            <summary>Convert an unsigned int to a date by adding seconds to Jan 1, 1970 0:0:0</summary>
            <remarks>http://jasonhaley.com/blog/post/2006/01/07/Get-a-DateTime-from-a-Coff-Headers-TimeDateStamp.aspx</remarks>
            <param name="timeDateStamp">Number of seconds to add to start date</param>
            <returns>DateTime timeDateStamp seconds after the start date</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.HiWord(System.UInt32)">
            <summary>Retrieves the high-order word from the specified 32-bit value.</summary>
            <param name="value">The value to be converted.</param>
            <returns>The return value is the high-order word of the specified value.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.LoWord(System.UInt32)">
            <summary>Retrieves the low-order word from the specified value.</summary>
            <param name="value">The value to be converted. </param>
            <returns>The return value is the low-order word of the specified value.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.HiByte(System.Int16)">
            <summary>The return value is the high-order byte of the specified value.</summary>
            <param name="value">The value to be converted.</param>
            <returns>The return value is the high-order byte of the specified value.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.LoByte(System.Int16)">
            <summary>The return value is the low-order byte of the specified value.</summary>
            <param name="value">The value to be converted. </param>
            <returns>The return value is the low-order byte of the specified value.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.MakeLong(System.Int32,System.Int32)">
            <summary>Makes a 64 bit long from two 32 bit integers</summary>
            <param name="low">The low order value.</param>
            <param name="high">The high order value.</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.MakeDword(System.Int16,System.Int16)">
            <summary>Makes a 32 bit integer from two 16 bit shorts</summary>
            <param name="low">The low order value.</param>
            <param name="high">The high order value.</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.MakeWord(System.Byte,System.Byte)">
            <summary>Makes a 16 bit short from two bytes</summary>
            <param name="low">The low order value.</param>
            <param name="high">The high order value.</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.SizeOf(System.Int16)">
            <summary>Gets the size of the input value in bits</summary>
            <param name="pInput">The input value</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.SizeOf(System.Int32)">
            <summary>Gets the size of the input value in bits</summary>
            <param name="pInput">The input value</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.SizeOf(System.Int64)">
            <summary>Gets the size of the input value in bits</summary>
            <param name="pInput">The input value</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.AlignToInt(System.UInt32)">
            <summary>Align padding to DWORD</summary>
            <param name="padding">Original padding</param>
            <returns>Aligned padding</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.AlignToShort(System.UInt32)">
            <summary>Align padding to WORD</summary>
            <param name="padding">Original padding</param>
            <returns>Aligned padding</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.GetKeyNameText(System.UInt32,System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves a string that represents the name of a key.</summary>
            <param name="lParam">The second parameter of the keyboard message (such as WM_KEYDOWN) to be processed.</param>
            <param name="lpString">The buffer that will receive the key name.</param>
            <param name="nSize">
            The maximum length, in characters, of the key name, including the terminating null character.
            (This parameter should be equal to the size of the buffer pointed to by the lpString parameter.)
            </param>
            <remarks>
            The format of the key-name string depends on the current keyboard layout.
            The keyboard driver maintains a list of names in the form of character strings for keys with names longer than a single character.
            The key name is translated according to the layout of the currently installed keyboard, thus the function may give different results for different input locales.
            The name of a character key is the character itself.
            The names of dead keys are spelled out in full.
            </remarks>
            <returns>If the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of the string, in characters, not counting the terminating null character.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.MapVirtualKey(System.UInt32,AlphaOmega.Debug.NativeMethods.MAPVK)">
            <summary>Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. </summary>
            <param name="uCode">The virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType parameter.</param>
            <param name="uMapType">The translation to be performed.</param>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms646306%28v=vs.85%29.aspx</remarks>
            <returns>The return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode and uMapType. If there is no translation, the return value is zero.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.GetModuleHandle(System.String)">
            <summary>Retrieves a module handle for the specified module. The module must have been loaded by the calling process.</summary>
            <param name="lpModuleName">
            The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended.
            The file name string can include a trailing point character (.) to indicate that the module name has no extension.
            The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/).
            The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.
            If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file).
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the specified module.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.LoadLibraryEx(System.String,System.IntPtr,AlphaOmega.Debug.NativeMethods.LoadLibraryFlags)">
            <summary>Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms684179%28v=vs.85%29.aspx</remarks>
            <param name="lpFileName">
            A string that specifies the file name of the module to load. This name is not related to the name stored in a library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
            The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified module is an executable module, static imports are not loaded; instead, the module is loaded as if DONT_RESOLVE_DLL_REFERENCES was specified. See the dwFlags parameter for more information.
            If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.
            If the string specifies a fully qualified path, the function searches only that path for the module. When specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths, see Naming Files, Paths, and Namespaces.
            If the string specifies a module name without a path and more than one loaded module has the same base name and extension, the function returns a handle to the module that was loaded first.
            If the string specifies a module name without a path and a module of the same name is not already loaded, or if the string specifies a module name with a relative path, the function searches for the specified module. The function also searches for modules if loading the specified module causes the system to load other associated modules (that is, if the module has dependencies). The directories that are searched and the order in which they are searched depend on the specified path and the dwFlags parameter. For more information, see Remarks.
            If the function cannot find the module or one of its dependencies, the function fails.
            </param>
            <param name="hReservedNull">This parameter is reserved for future use. It must be NULL.</param>
            <param name="dwFlags">
            The action to be taken when loading the module.
            If no flags are specified, the behavior of this function is identical to that of the LoadLibrary function.
            </param>
            <returns>If the function succeeds, the return value is a handle to the loaded module.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.LoadLibrary(System.String)">
            <summary>Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms684175%28v=vs.85%29.aspx</remarks>
            <param name="lpFileName">
            The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
            If the string specifies a full path, the function searches only that path for the module.
            If the string specifies a relative path or a module name without a path, the function uses a standard search strategy to find the module; for more information, see the Remarks.
            If the function cannot find the module, the function fails. When specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths, see Naming a File or Directory.
            If the string specifies a module name without a path and the file name extension is omitted, the function appends the default library extension .dll to the module name. To prevent the function from appending .dll to the module name, include a trailing point character (.) in the module name string.
            </param>
            <returns>If the function succeeds, the return value is a handle to the module.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.FreeLibrary(System.IntPtr)">
            <summary>
            Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count.
            When the reference count reaches zero, the module is unloaded from the address space of the calling process and the handle is no longer valid.
            </summary>
            <param name="hModule">
            A handle to the loaded library module.
            The LoadLibrary, LoadLibraryEx, GetModuleHandle, or GetModuleHandleEx function returns this handle.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call the GetLastError function.
            </returns>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms683152%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.ImageRvaToVa(System.IntPtr,System.IntPtr,System.UInt32,System.IntPtr)">
            <summary>Locates a relative virtual address (RVA) within the image header of a file that is mapped as a file and returns the virtual address of the corresponding byte in the file.</summary>
            <param name="NtHeaders">A pointer to an IMAGE_NT_HEADERS structure. This structure can be obtained by calling the ImageNtHeader function.</param>
            <param name="Base">The base address of an image that is mapped into memory through a call to the MapViewOfFile function.</param>
            <param name="Rva">The relative virtual address to be located.</param>
            <param name="LastRvaSection">
            A pointer to an IMAGE_SECTION_HEADER structure that specifies the last RVA section. This is an optional parameter.
            When specified, it points to a variable that contains the last section value used for the specified image to translate an RVA to a VA.
            </param>
            <returns>
            If the function succeeds, the return value is the virtual address in the mapped file.
            If the function fails, the return value is NULL. To retrieve extended error information, call GetLastError.
            </returns>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms680218%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.GetProcAddress(System.IntPtr,System.IntPtr)">
            <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
            <param name="hModule">
            A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx, LoadPackagedLibrary, or GetModuleHandle function returns this handle.
            The GetProcAddress function does not retrieve addresses from modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx.
            </param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            If the function succeeds, the return value is the address of the exported function or variable.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.GetProcAddress(System.IntPtr,System.String)">
            <summary>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</summary>
            <param name="hModule">
            A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx, LoadPackagedLibrary, or GetModuleHandle function returns this handle.
            The GetProcAddress function does not retrieve addresses from modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx.
            </param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            If the function succeeds, the return value is the address of the exported function or variable.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:AlphaOmega.Debug.NativeMethods.VirtualAlloc(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Reserves or commits a region of pages in the virtual address space of the calling process.
            Memory allocated by this function is automatically initialized to zero, unless MEM_RESET is specified.
            </summary>
            <param name="lpStartAddr">
            The starting address of the region to allocate.
            If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity.
            If the memory is already reserved and is being committed, the address is rounded down to the next page boundary.
            To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function.
            If this parameter is NULL, the system determines where to allocate the region.
            </param>
            <param name="size">
            The size of the region, in bytes.
            If the lpAddress parameter is NULL, this value is rounded up to the next page boundary.
            Otherwise, the allocated pages include all pages containing one or more bytes in the range from lpAddress to lpAddress+dwSize.
            This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.
            </param>
            <param name="flAllocationType">The type of memory allocation.</param>
            <param name="flProtect">
            The memory protection for the region of pages to be allocated.
            If the pages are being committed, you can specify any one of the memory protection constants.
            </param>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887%28v=vs.85%29.aspx</remarks>
            <returns>
            If the function succeeds, the return value is the base address of the allocated region of pages.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="T:AlphaOmega.Debug.NativeMethods.MAPVK">
            <summary>The translation to be performed.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.MAPVK.VK_TO_CHAR">
            <summary>
            uCode is a virtual-key code and is translated into an unshifted character value in the low-order word of the return value.
            Dead keys (diacritics) are indicated by setting the top bit of the return value.
            If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.MAPVK.VK_TO_VSC">
            <summary>
            uCode is a virtual-key code and is translated into a scan code.
            If it is a virtual-key code that does not distinguish between left- and right-hand keys, the left-hand scan code is returned.
            If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.MAPVK.VSC_TO_VK">
            <summary>
            uCode is a scan code and is translated into a virtual-key code that does not distinguish between left- and right-hand keys.
            If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.MAPVK.VSC_TO_VK_EX">
            <summary>
            uCode is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand keys.
            If there is no translation, the function returns 0.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags">
            <summary>
            The action to be taken when loading the module.
            If no flags are specified, the behavior of this function is identical to that of the LoadLibrary function.
            This parameter can be one of the following values.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms684179%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.DONT_RESOLVE_DLL_REFERENCES">
            <summary>
            If this value is used, and the executable module is a DLL, the system does not call DllMain for process and thread initialization and termination.
            Also, the system does not load additional executable modules that are referenced by the specified module.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_IGNORE_CODE_AUTHZ_LEVEL">
            <summary>
            If this value is used, the system does not check AppLocker rules or apply Software Restriction Policies for the DLL.
            This action applies only to the DLL being loaded and not to its dependencies.
            This value is recommended for use in setup programs that must run extracted DLLs during installation.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE">
            <summary>
            If this value is used, the system maps the file into the calling process's virtual address space as if it were a data file.
            Nothing is done to execute or prepare to execute the mapped file.
            Therefore, you cannot call functions like GetModuleFileName, GetModuleHandle or GetProcAddress with this DLL.
            Using this value causes writes to read-only memory to raise an access violation. Use this flag when you want to load a DLL only to extract messages or resources from it.
            This value can be used with <see cref="T:LOAD_LIBRARY_AS_IMAGE_RESOURCE"/>. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE">
            <summary>
            Similar to <see cref="T:LOAD_LIBRARY_AS_DATAFILE"/>, except that the DLL file is opened with exclusive write access for the calling process.
            Other processes cannot open the DLL file for write access while it is in use.
            However, the DLL can still be opened by other processes.
            This value can be used with <see cref="T:LOAD_LIBRARY_AS_IMAGE_RESOURCE"/>. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE">
            <summary>
            If this value is used, the system maps the file into the process's virtual address space as an image file.
            However, the loader does not load the static imports or perform the other usual initialization steps.
            Use this flag when you want to load a DLL only to extract messages or resources from it.
            If forced integrity checking is desired for the loaded file then <see cref="T:LOAD_LIBRARY_AS_IMAGE"/> is recommended instead.
            Unless the application depends on the image layout, this value should be used with either <see cref="T:LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE"/> or <see cref="T:LOAD_LIBRARY_AS_DATAFILE"/>.
            For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR">
            <summary>
            If this value is used, the application's installation directory is searched for the DLL and its dependencies.
            Directories in the standard search path are not searched.
            This value cannot be combined with <see cref="T:LOAD_WITH_ALTERED_SEARCH_PATH"/>.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS">
            <summary>
            This value is a combination of <see cref="T:LOAD_LIBRARY_SEARCH_APPLICATION_DIR"/>, <see cref="T:LOAD_LIBRARY_SEARCH_SYSTEM32"/>, and <see cref="T:LOAD_LIBRARY_SEARCH_USER_DIRS"/>.
            Directories in the standard search path are not searched. This value cannot be combined with <see cref="T:LOAD_WITH_ALTERED_SEARCH_PATH"/>.
            This value represents the recommended maximum number of directories an application should include in its DLL search path.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR">
            <summary>
            If this value is used, the directory that contains the DLL is temporarily added to the beginning of the list of directories that are searched for the DLL's dependencies.
            Directories in the standard search path are not searched.
            The lpFileName parameter must specify a fully qualified path.
            This value cannot be combined with <see cref="T:LOAD_WITH_ALTERED_SEARCH_PATH"/>.
            For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading Lib1.dll with this value causes the system to search for Lib2.dll only in C:\Dir1.
            To search for Lib2.dll in C:\Dir1 and all of the directories in the DLL search path, combine this value with <see cref="T:LOAD_LIBRARY_DEFAULT_DIRS"/>.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_SEARCH_SYSTEM32">
            <summary>
            If this value is used, %windows%\system32 is searched for the DLL and its dependencies.
            Directories in the standard search path are not searched.
            This value cannot be combined with <see cref="T:LOAD_WITH_ALTERED_SEARCH_PATH"/>.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_LIBRARY_SEARCH_USER_DIRS">
            <summary>
            If this value is used, directories added using the AddDllDirectory or the SetDllDirectory function are searched for the DLL and its dependencies.
            If more than one directory has been added, the order in which the directories are searched is unspecified.
            Directories in the standard search path are not searched.
            This value cannot be combined with <see cref="T:LOAD_WITH_ALTERED_SEARCH_PATH"/>.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.NativeMethods.LoadLibraryFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
            <summary>
            If this value is used and lpFileName specifies an absolute path, the system uses the alternate file search strategy discussed in the Remarks section to find associated executable modules that the specified module causes to be loaded.
            If this value is used and lpFileName specifies a relative path, the behavior is undefined.
            If this value is not used, or if lpFileName does not specify a path, the system uses the standard search strategy discussed in the Remarks section to find associated executable modules that the specified module causes to be loaded.
            This value cannot be combined with any <see cref="T:LOAD_LIBRARY_SEARCH"/> flag.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceMenu">
            <summary>Menu resource class</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceBase">
            <summary>Base class of resource directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceBase.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory,AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE)">
            <summary>Create instance of resource directory class</summary>
            <param name="directory">Parent PE directory</param>
            <param name="type">Resource directory type</param>
            <exception cref="T:ArgumentNullException">directory is null</exception>
            <exception cref="T:InvalidOperationException">directory type must be equals to type</exception>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceBase.GetSzOrInt(AlphaOmega.Debug.BytesReader,System.UInt32@)">
            <summary>Read integer or string from mapped object</summary>
            <param name="reader">Resource allocated bytes array</param>
            <param name="padding">Padding from the beginning</param>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceBase.CreateDataReader">
            <summary>Create data reader for data in directory</summary>
            <returns>Memory pinned data reader</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.Directory">
            <summary>Сама директория из которой получаем ресурсы</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.Type">
            <summary>Тип директории</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt">
            <summary>String or integer structure</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.ToString">
            <summary>Convert stored value to string</summary>
            <exception cref="T:NotImplementedException">Unknown pointer type specified</exception>
            <returns>String</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.Index">
            <summary>Index in resource file</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.Name">
            <summary>String</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.IsEmpty">
            <summary>Value is empty</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.Type">
            <summary>Type of value stored in the structure</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.SzIntResult">
            <summary>Type of data in structure</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.SzIntResult.None">
            <summary>Empty index</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.SzIntResult.Index">
            <summary>Index in resource file</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceBase.SzInt.SzIntResult.Name">
            <summary>String</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of menu resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.GetMenuTemplate">
            <summary>Get menu from resources</summary>
            <remarks>
            На выбор:
            Описание меню: http://msdn.microsoft.com/en-us/library/windows/desktop/ms647558%28v=vs.85%29.aspx
            Описание всех ресурсов включая меню: http://msdn.microsoft.com/en-us/library/windows/desktop/ms648007%28v=vs.85%29.aspx
            </remarks>
            <returns>Menu</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.GetMenu(System.UInt32)">
            <summary>Gets menu items from padding</summary>
            <param name="padding">Starting menu padding</param>
            <exception cref="T:InvalidOperationException">Can't find end of menu marker</exception>
            <returns>Menu items</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.GetPopupMenu(AlphaOmega.Debug.BytesReader,System.UInt32@)">
            <summary>Gets popup menu items from padding</summary>
            <param name="reader">Menu bytes</param>
            <param name="padding">Starting popup menu padding</param>
            <exception cref="T:InvalidOperationException">Can't find end of menu marker</exception>
            <returns>Readed popup menu items</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.GetMenuOld(System.UInt32)">
            <summary>Получить меню старого образца</summary>
            <param name="padding">Отступ от начала меню</param>
            <returns>Элементы меню</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMenu.GetPopupMenuOld(AlphaOmega.Debug.BytesReader,System.UInt32@)">
            <summary>Получить всплывающее меню</summary>
            <param name="reader">Allocated bytes in memory</param>
            <param name="padding">Отступ от начала</param>
            <exception cref="T:InvalidOperationException">Cand find end of menu marker</exception>
            <returns>Всплывающее меню</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMenu.Header">
            <summary>Resource menu header</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem">
            <summary>Root menu item</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.dwHelpId">
            <summary>Help ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.Item">
            <summary>Defines a menu item in a menu template.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.ItemEx">
            <summary>Contains information about each item in a menu resource that does not open a menu or a submenu.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.Title">
            <summary>Menu item title</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.SubItems">
            <summary>Popup items</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.IsExMenu">
            <summary>Extended template</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuItem.IsSeparator">
            <summary>Specifies that the menu item is a separator.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem">
            <summary>Popup menu item</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.dwHelpId">
            <summary>Help ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.Item">
            <summary>Defines a menu item in a menu template.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.ItemEx">
            <summary>Contains information about each item in a menu resource that does not open a menu or a submenu.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.Title">
            <summary>Menu item title</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.SubItems">
            <summary>Popup items</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.IsExMenu">
            <summary>Extended template</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMenu.MenuPopupItem.IsSepearator">
            <summary>Specifies that the menu item is a separator.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceFontDir">
            <summary>Font directory resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceFontDir.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of font directory resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceFontDir.GetEnumerator">
            <summary>Get all fonts from directory</summary>
            <returns>Fonts from directory</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceFontDir.NumberOfFonts">
            <summary>Получить кол-во шрифтов в директории</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceFontDir.FontDirEntry">
            <summary>Font dir info</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceFont.FontEntry">
            <summary>Font info</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceFont">
            <summary>Font resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceFont.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of font resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceFont.Font">
            <summary>Font in resource directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceFont.FontEntry">
            <summary>Font info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceFont.FontEntry.Font">
            <summary>Contains information about an individual font in a font resource group.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceFont.FontEntry.szDeviceName">
            <summary>The name of the device if this font file is designated for a specific device.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceFont.FontEntry.szFaceName">
            <summary>The typeface name of the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceFontDir.FontDirEntry.fontOrdinal">
            <summary>A unique ordinal identifier for an individual font in a font resource group.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.RelocationBlock">
            <summary>Relocation block info</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.RelocationBlock.#ctor(AlphaOmega.Debug.WinNT.IMAGE_BASE_RELOCATION,AlphaOmega.Debug.NTDirectory.RelocationSection[])">
            <summary>Create instance of relocation block info</summary>
            <param name="block">Relocation block</param>
            <param name="sections">Array of sections</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.RelocationBlock.GetEnumerator">
            <summary>Sections in current relocation block</summary>
            <returns>Relocation sections</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.RelocationBlock.Block">
            <summary>Relocation block</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.RelocationBlock.Item(System.Int32)">
            <summary>Get relocation section by index</summary>
            <param name="index">Relocation section index</param>
            <returns>Section</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.RelocationBlock.Count">
            <summary>Count of sections in the relocation block</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.DelayImport">
            <summary>Delay import class</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.NTDirectoryBase">
            <summary>Base class of PE directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.IDirectory">
            <summary>Интерфейс директории в PE файле</summary>
        </member>
        <member name="P:AlphaOmega.Debug.IDirectory.IsEmpty">
            <summary>Директория пустая</summary>
        </member>
        <member name="P:AlphaOmega.Debug.IDirectory.Directory">
            <summary>Описатель директории</summary>
        </member>
        <member name="T:AlphaOmega.Debug.ISectionData">
            <summary>Получение данных из секции</summary>
        </member>
        <member name="M:AlphaOmega.Debug.ISectionData.GetData">
            <summary>Получить все данные в виде массива байт из секции PE файла</summary>
            <returns>Массив байт в секции</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.NTDirectoryBase.#ctor(AlphaOmega.Debug.PEDirectory,AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY)">
            <summary>Create instance</summary>
            <param name="parent">Parent PE directory</param>
            <param name="directory">Directory type</param>
            <exception cref="T:ArgumentNullException">parent directory is null</exception>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.NTDirectoryBase.GetData">
            <summary>Получить все данные из директории</summary>
            <returns>Массив данных из директории</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.NTDirectoryBase.Parent">
            <summary>Директория PE файла</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.NTDirectoryBase.IsEmpty">
            <summary>Директроия пустая</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.NTDirectoryBase.Directory">
            <summary>Данные директории</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DelayImport.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of delay import class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DelayImport.GetEnumerator">
            <summary>Get array of delay import modules and procedures</summary>
            <returns>Delay import modules</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRefRow">
            <summary>The rows in the ModuleRef table result from .module extern directives in the Assembly (§II.6.5).</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaRow">
            <summary>Базовый класс для детального описания ряда таблицы в метаданных</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaRow.GetValue``1(System.UInt32)">
            <summary>Получить значение из колонки ряда по значению</summary>
            <typeparam name="T">Тип данных в колонке</typeparam>
            <param name="columnIndex">Индекс колонки в таблице метаданных</param>
            <returns>Значение колонки в таблице метаданных</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaRow.IsBitSet(System.UInt32,System.UInt32)">
            <summary>Проверка на наличие бита дабы уменьшить синтаксис</summary>
            <param name="flags">Флаги</param>
            <param name="enumValue">Значение бита, которое надо проверить</param>
            <returns>Бит проставлен</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaRow.Row">
            <summary>Базовый ряд для обработки</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRefRow.Name">
            <summary>
            This string shall enable the CLI to locate the target module
            (typically, it might name the file used to hold the module).
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FileRow">
            <summary>The rows of the File table result from .file directives in an Assembly (§II.6.2.3).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FileRow.Flags">
            <summary>A 4-byte bitmask of type FileAttributes, §II.23.1.6</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FileRow.Name">
            <summary>File name with name and extension.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FileRow.HashValue">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.StreamLoader">
            <summary>Image loader from file or stream</summary>
        </member>
        <member name="T:AlphaOmega.Debug.IImageLoader">
            <summary>Загрузчик PE файла</summary>
        </member>
        <member name="M:AlphaOmega.Debug.IImageLoader.PtrToStructure``1(System.UInt32)">
            <summary>Получить структуру с определённого отступа</summary>
            <typeparam name="T">Структура</typeparam>
            <param name="padding">Отступ от начала файла или RVA</param>
            <returns>Прочитанная структура</returns>
        </member>
        <member name="M:AlphaOmega.Debug.IImageLoader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Получить массив байт с начала отступа</summary>
            <param name="padding">Отступ от начала файла или RVA</param>
            <param name="length">Читаемый размер</param>
            <returns>Получить массив байт с отступа</returns>
        </member>
        <member name="M:AlphaOmega.Debug.IImageLoader.PtrToStringAnsi(System.UInt32)">
            <summary>Получить строку с отпределённого отступа</summary>
            <param name="padding">Отступ от начала файла или RVA</param>
            <returns>Прочитанная строка</returns>
        </member>
        <member name="P:AlphaOmega.Debug.IImageLoader.IsModuleMapped">
            <summary>Модуль загружен в память. Все RVA адреса переписаны в VA.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.IImageLoader.BaseAddress">
            <summary>Базовый адрес загруженного модуля в память</summary>
        </member>
        <member name="P:AlphaOmega.Debug.IImageLoader.Source">
            <summary>Источник получения PE файла</summary>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.#ctor(System.IO.Stream,System.String)">
            <summary>Read image from stream</summary>
            <param name="input">Stream with image</param>
            <param name="source">Source of image</param>
            <exception cref="T:ArgumentNullException">input stream is null</exception>
            <exception cref="T:ArgumentNullException">souce is null</exception>
            <exception cref="T:ArgumentException">stream must be seakable and readable</exception>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.FromFile(System.String)">
            <summary>Read PE image from file</summary>
            <param name="filePath">Path to the file</param>
            <exception cref="T:ArgumentNullException">filePath is null</exception>
            <exception cref="T:FileNotFoundException">filePath not found</exception>
            <returns>PE loader</returns>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.FromMemory(System.Byte[],System.String)">
            <summary>Read PE image from memory</summary>
            <param name="input">Array of bytes</param>
            <param name="sourceName">Custom source name</param>
            <returns>PE loader</returns>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Get bytes from specific padding and specific length</summary>
            <param name="padding">Padding from the beginning of the image</param>
            <param name="length">Length of bytes to read</param>
            <exception cref="T:ArgumentOutOfRangeException">padding + length more than size of image</exception>
            <returns>Readed bytes</returns>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.PtrToStructure``1(System.UInt32)">
            <summary>Get structure from specific padding from the beginning of the image</summary>
            <typeparam name="T">Structure type</typeparam>
            <param name="padding">Padding from the beginning of the image</param>
            <returns>Readed structure from image</returns>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.PtrToStringAnsi(System.UInt32)">
            <summary>Get ACSII string from specific padding from the beginning of the image</summary>
            <param name="padding">Padding from the beginning of the image</param>
            <exception cref="T:ArgumentOutOfRangeException">padding more than size of image</exception>
            <returns>String from pointer</returns>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.Dispose">
            <summary>Close PE reader</summary>
        </member>
        <member name="M:AlphaOmega.Debug.StreamLoader.Dispose(System.Boolean)">
            <summary>Dispose managed objects</summary>
            <param name="disposing">Dispose managed objects</param>
        </member>
        <member name="P:AlphaOmega.Debug.StreamLoader.Reader">
            <summary>File reader</summary>
            <exception cref="T:System.ObjectDisposedException">Base stream disposed</exception>
        </member>
        <member name="P:AlphaOmega.Debug.StreamLoader.IsModuleMapped">
            <summary>Modeul Mapped to memory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.StreamLoader.BaseAddress">
            <summary>Base PE file address</summary>
        </member>
        <member name="P:AlphaOmega.Debug.StreamLoader.Source">
            <summary>File source</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Security">
            <summary>Certificate class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Security.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of certificate class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Security.IsEmpty">
            <summary>PE file contains certificate</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Security.Certificate">
            <summary>Certificate header</summary>
            <exception cref="T:ArgumentOutOfRangeException">Directory VA out of file size</exception>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Security.X509">
            <summary>X.509 certificate</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Import">
            <summary>Impot directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Import.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of Import directory class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Import.GetEnumerator">
            <summary>Get all import modules from image</summary>
            <returns>Import modules</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Import.ImportDescriptor">
            <summary>Первый дескриптор импортируемых функций</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.StreamTables">
            <summary>MetaData tables</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader">
            <summary>Stream header class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of stream header class</summary>
            <param name="loader">MetaData</param>
            <param name="header">Stream header</param>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader.Parent">
            <summary>Parent MetaData directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader.Header">
            <summary>Stream header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader.Position">
            <summary>Стартовая позиция с которой начинается куча</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamHeader.Bytes">
            <summary>Массив байт, в куче</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of stream tables class</summary>
            <param name="meta">MetaData directory</param>
            <param name="header">stream header</param>
            <exception cref="T:InvalidOperationException">StreamTable can only read optimized or unoptimized stream tables</exception>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.DataBind">
            <summary>Получить данные всех таблиц</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AddTable(AlphaOmega.Debug.Cor.MetaTableType,System.UInt32@)">
            <summary>Создать таблицу мета-данных</summary>
            <param name="tableType">Тип создаваемой таблицы</param>
            <param name="padding">Отступ от начала потока с мета данными</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.GetRowsCount">
            <summary>Получить кол-во рдво во всех таблицах</summary>
            <returns>Кол-во рядов во всех таблицах</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.GetRowsCount(AlphaOmega.Debug.Cor.MetaTableType)">
            <summary>Получить кол-во рядов в определённой таблице</summary>
            <param name="tableType">Таблица для которой получить кол-во рядов</param>
            <returns>Кол-во рядов в определённой таблице</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.GetRowsCountI">
            <summary>Код получение списка нераспакованных таблиц</summary>
            <returns>Список нераспакованных таблиц</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Item(AlphaOmega.Debug.Cor.MetaTableType)">
            <summary>Таблица с информацией о типе</summary>
            <param name="tableType">Тип таблицы</param>
            <returns>Данные в таблице</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Module">
            <summary>Module descriptor.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.TypeRef">
            <summary>Class reference descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.TypeDef">
            <summary>Class or interface definition descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.FieldPtr">
            <summary>A class-to-fields lookup table, whitch does not exist on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Field">
            <summary>A field definition descriptos.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MethodPtr">
            <summary>A class-to-methods lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MethodDef">
            <summary>Method definition descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ParamPtr">
            <summary>A method-to-parameters lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Param">
            <summary>Parameter definition descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.InterfaceImpl">
            <summary>Interface implementation descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MemberRef">
            <summary>Member (field or method) reference descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Constant">
            <summary>Constant value descriptors that map the default values stored in the #Blob stream to respective fields, parameters, and properties.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.CustomAttribute">
            <summary>Custom attribute descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.FieldMarshal">
            <summary>Field or parameter marshaling descriptors for managed/unmanaged interoperations.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.DeclSecurity">
            <summary>Security descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ClassLayout">
            <summary>Class layout descriptors that hold information about how the loader should lay out respective classes.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.FieldLayout">
            <summary>Field layout descriptors that specify the offset or ordinal of invidual fields.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.StandAloneSig">
            <summary>Stand-alone signature descriptors. Signatures per se are used in two capacities: as composite signatures of local variables of methods and as parameters of the call indirect (calli) IL instruction.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.EventMap">
            <summary>
            A class-to-events mapping table.
            This is not an intermidate lookup table, and it does not exist in optimized metadata.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.EventPtr">
            <summary>An event map-to-events lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Event">
            <summary>Event descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.PropertyMap">
            <summary>
            A class-to-properties mapping table.
            This is not an intermidate lookup table, and it does not exist in optimized metadata.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.PropertyPtr">
            <summary>A property map-to-properties lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Property">
            <summary>Property descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MethodSemantics">
            <summary>Method semantics descriptors that hold information about whitch method is associated with a specific property or event and in what capacity.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MethodImpl">
            <summary>Method implementation descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ModuleRef">
            <summary>Module reference descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.TypeSpec">
            <summary>
            The TypeSpec table has just one column, which indexes the specification of a Type, stored in the Blob heap.
            This provides a metadata token for that Type (rather than simply an index into the Blob heap).
            This is required, typically, for array operations, such as creating, or calling methods on the array class.
            </summary>
            <remarks>
            Note that TypeSpec tokens can be used with any of the CIL instructions that take a TypeDef or TypeRef token;
            specifically, castclass, cpobj, initobj, isinst, ldelema, ldobj, mkrefany, newarr, refanyval, sizeof, stobj, box, and unbox.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ImplMap">
            <summary>Implementation map descriptors used for the platform invocation (P/Invoke) type of managed/unmanaged code interoperation.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.FieldRVA">
            <summary>Field-to-data mapping descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ENCLog">
            <summary>
            Edit-and-continue log descriptors that hold information about what changes have been made to specific metadata items during in-memory editing.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ENCMap">
            <summary>
            Edit-and-continue mapping descriptors.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Assembly">
            <summary>The current assembly descriptor, whitch sould appear only in the prime moduel metadata.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AssemblyProcessor">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AssemblyOS">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AssemblyRef">
            <summary>Assembly reference descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AssemblyRefProcessor">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.AssemblyRefOS">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.File">
            <summary>File descriptors that contain information about other files in the current assembly.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ExportedType">
            <summary>
            Exported type descriptors that contain information about public classes exported by the current assembly, whitch are declared in other modules of the assembly.
            Only the prime module of the assembly sould carry this table.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.ManifestResource">
            <summary>Managed resource descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.NestedClass">
            <summary>Nested class descriptors that provide mapping of nested classes to their respective enclosing classes.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.GenericParam">
            <summary>Type parameter descriptors for generic (parameterized) classes and methods.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.MethodSpec">
            <summary>Generic method instantiation descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.GenericParamConstraint">
            <summary>Descriptors of constraints specified for type parameters of generic classes and methods.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.StreamTableHeader">
            <summary>Table header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.Position">
            <summary>Tables position</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StreamTables.DataPosition">
            <summary>Позиция, с которых начинаются данные в таблицах</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeSpecRow">
            <summary>
            The TypeSpec table has just one column, which indexes the specification of a Type, stored in the Blob heap.
            This provides a metadata token for that Type (rather than simply an index into the Blob heap).
            This is required, typically, for array operations, such as creating, or calling methods on the array class.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeSpecRow.Signature">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ConstantRow">
            <summary>The Constant table is used to store compile-time, constant values for fields, parameters, and properties.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ConstantRow.Type">
            <summary>A 1-byte constant, followed by a 1-byte padding zero.</summary>
            <remarks>
            The encoding of Type for the nullref value for FieldInit in ilasm (§II.16.2)
            is <see cref="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CLASS"/> with a Value of a 4-byte zero.
            Unlike uses of <see cref="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CLASS"/> in signatures, this one is not followed by a type token.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ConstantRow.Parent">
            <summary>
            An index into the Param, Field, or Property table;
            more precisely, a HasConstant (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ConstantRow.Value">
            <summary>Constant value</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.GlobalPtr">
            <summary>The RVA of the value to be stored in the global pointer register.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.GlobalPtr.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of TLS class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamRow">
            <summary>
            The GenericParam table stores the generic parameters used in generic type definitions
            and generic method definitions.
            These generic parameters can be constrained (i.e., generic arguments
            shall extend some class and/or implement certain interfaces) or unconstrained.
            (Such constraints are stored in the GenericParamConstraint table.)
            </summary>
            <remarks>Conceptually, each row in the GenericParam table is owned by one, and only one, row in either the TypeDef or MethodDef tables.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamRow.Number">
            <summary>Parameter index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamRow.Flags">
            <summary>Generic parameter constraint</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamRow.Owner">
            <summary>
            An index into the TypeDef or MethodDef table, specifying the Type or Method
            to which this generic parameter applies; more precisely, a TypeOrMethodDef (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamRow.Name">
            <summary>Name for the generic parameter.</summary>
            <remarks>This is purely descriptive and is used only by source language compilers and by Reflection</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT">
            <summary>Структуры COFF/PE файла</summary>
            <remarks>Описание в WinNT.h</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Signature4b">
            <summary>4 byte packing is the default</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Signature4b.IMAGE_DOS_SIGNATURE">
            <summary>DOS signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Signature4b.IMAGE_OS2_SIGNATURE">
            <summary>OS/2 signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Signature4b.IMAGE_OS2_SIGNATURE_LE">
            <summary>Little Endian signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Signature4b.IMAGE_NT_SIGNATURE">
            <summary>NT signature</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE">
            <summary>The architecture type of the computer. An image file can only be run on the specified computer or a system that emulates the specified computer.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.UNKNOWN">
            <summary>The contents of this field are assumed to be applicable to any machine type</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.I860">
            <summary>Intel 860.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.I386">
            <summary>Intel 386 or later processors and compatible processors</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.R3000">
            <summary>MIPS little-endian, 0x160 big-endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.R4000">
            <summary>MIPS little endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.R10000">
            <summary>MIPS little-endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.WCEMIPSV2">
            <summary>MIPS little-endian WCE v2</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.ALPHA">
            <summary>Alpha_AXP</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.SH3">
            <summary>Hitachi SH3</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.SH3DSP">
            <summary>Hitachi SH3 DSP</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.SH3E">
            <summary>SH3E little-endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.SH4">
            <summary>Hitachi SH4</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.SH5">
            <summary>Hitachi SH5</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.ARM">
            <summary>ARM little endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.THUMB">
            <summary>ARM or Thumb (“interworking”)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.ARMV7">
            <summary>ARMv7 (or higher) Thumb mode only</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.AM33">
            <summary>Matsushita AM33</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.POWERPC">
            <summary>Power PC little endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.POWERPCFP">
            <summary>Power PC with floating point support</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.IA64">
            <summary>Intel Itanium processor family</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.MIPS16">
            <summary>MIPS16</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.ALPHA64">
            <summary>ALPHA64</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.MIPSFPU">
            <summary>MIPS with FPU</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.MIPSFPU16">
            <summary>MIPS16 with FPU</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.TRICORE">
            <summary>Infineon</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.CEF">
            <summary>CEF</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.EBC">
            <summary>EFI byte code</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.AMD64">
            <summary>AMD64 (K8)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.M32R">
            <summary>Mitsubishi M32R little endian</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_MACHINE.CEE">
            <summary>CEE</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_SIGNATURE">
            <summary>The state of the image file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SIGNATURE.IMAGE_NT_OPTIONAL_HDR32_MAGIC">
            <summary>The file is an executable 32bit version image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SIGNATURE.IMAGE_NT_OPTIONAL_HDR64_MAGIC">
            <summary>The file is an executable 64bit version image.</summary>
            <remarks>
            PE32+ images allow for a 64-bit address space while limiting the image size to 2 gigabytes.
            Other PE32+ modifications are addressed in their respective sections.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SIGNATURE.IMAGE_ROM_OPTIONAL_HDR_MAGIC">
            <summary>The file is a ROM image.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM">
            <summary>The subsystem required to run this image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.UNKNOWN">
            <summary>An unknown subsystem.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.NATIVE">
            <summary>Device drivers and native Windows processes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.WINDOWS_GUI">
            <summary>The Windows graphical user interface (GUI) subsystem.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.WINDOWS_CUI">
            <summary>The Windows character subsystem.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.OS2_CUI">
            <summary>OS/2 CUI subsystem.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.POSIX_CUI">
            <summary>The Posix character (CUI) subsystem.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.WINDOWS_CE_GUI">
            <summary>Windows CE.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.EFI_APPLICATION">
            <summary>An Extensible Firmware Interface (EFI) application.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.EFI_BOOT_SERVICE_DRIVER">
            <summary>An EFI driver with boot services.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.EFI_RUNTIME_DRIVER">
            <summary>An EFI driver with run-time services.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.EFI_ROM">
            <summary>An EFI ROM image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.XBOX">
            <summary>XBOX system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SUBSYSTEM.WINDOWS_BOOT_APPLICATION">
            <summary>Boot application.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS">
            <summary>The DLL characteristics of the image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_0">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_1">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_2">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_3">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.DYNAMIC_BASE">
            <summary>DLL can be relocated at load time.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.FORCE_INTEGRITY">
            <summary>
            Code Integrity checks are enforced.
            If you set this flag and a section contains only uninitialized data,
            set the PointerToRawData member of <see cref="T:IMAGE_SECTION_HEADER"/> for that section to zero;
            otherwise, the image will fail to load because the digital signature cannot be verified.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.NX_COMPAT">
            <summary>The image is compatible with data execution prevention (DEP).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.NO_ISOLATION">
            <summary>The image is isolation aware, but should not be isolated.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.NO_SEH">
            <summary>The image does not use structured exception handling (SEH). No handlers can be called in this image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.NO_BIND">
            <summary>Do not bind the image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_4">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.WDM_DRIVER">
            <summary>A WDM driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.RES_5">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DLLCHARACTERISTICS.TERMINAL_SERVER_AWARE">
            <summary>The image is terminal server aware.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE">
            <summary>The format of the debugging information</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.UNKNOWN">
            <summary>Unknown value, ignored by all tools.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.COFF">
            <summary>COFF debugging information (line numbers, symbol table, and string table). This type of debugging information is also pointed to by fields in the file headers.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.CODEVIEW">
            <summary>CodeView debugging information. The format of the data block is described by the CodeView 4.0 specification.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.FPO">
            <summary>Frame pointer omission (FPO) information. This information tells the debugger how to interpret nonstandard stack frames, which use the EBP register for a purpose other than as a frame pointer.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.MISC">
            <summary>The location of DBG file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.EXCEPTION">
            <summary>A copy of .pdata section.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.FIXUP">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.OMAP_TO_SRC">
            <summary>The mapping from an RVA in image to an RVA in source image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.OMAP_FROM_SRC">
            <summary>The mapping from an RVA in source image to an RVA in image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.BORLAND">
            <summary>Reserved for Borland.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.RESERVED10">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE.CLSID">
            <summary>Reserved.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS">
            <summary>COM+ Header entry point flags.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS.ILONLY">
            <summary>
            The image contains IL code only, with no embedded native unmanaged code except the start-up stub (whitch simply executes an indirect jump to the CLR entry point).
            Common language runtime-aware operating systems (such as Windows XP and newer) ignore the start-up stub and invoke the CLR automatically, so for all practical purposes the file can be considered pure IL.
            Howewer, setting this flag can cause certain problems when running under Windows XP and newer.
            If this flag is set, the OS loader of Windows XP and newer ignores not only the start-up stub but also the .reloc section, whitch in this case contains single relocation (or single pair of relocations in IA64-specific images) for the CLR entry point.
            However, the .reloc section can contain relocations for the beginning and end of the .tls section as well as relocations for what is referred to as "data on data" (that is, data constants that are pointers to other data constants).
            Among existing managed compilers, only the VC++ and the IL assembler can produce this items.
            The VC++ of v7.0 and v7.1 (corresponding to CLR version 1.0 and 1.1) newer set this flag because the image file it generated was newer pure IL.
            In v2.0 this situation has changed, and currently, th VC++ and IL assembler are the only two capable of producing pure-IL image files that might require additional relocations in the .reloc section.
            To resolve this problem, the IL assembler, if TLS-based data or data on data is emitted, clears this flag and, if the target platform is 32-bit, sets the <see cref="T:_32BITREQUIRED"/> flag instead.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS._32BITREQUIRED">
            <summary>
            The image file can be loaded only into a 32-bit process.
            This flag is set alone when native unmanaged code is embedded in the PE file or when the .reloc section contains additional relocations or is set in combination with <see cref="T:ILONLY"/> when the executable does not contain additional relocations but is in some way 32-bit specific
            (for example, invokes an unmanaged 32-bit specific API or uses 4-byte integers to store pinters).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS.IL_LIBRARY">
            <summary>
            This flag is obsolete and should not be set.
            Setting it as the IL assembler allows, using the .corflags directive - will render your module unloadable.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS.STRONGNAMESIGNED">
            <summary>
            The image file is protected with strong name signature.
            The strong name signature includes the public key and the signature hash and is a part of an assembly's identity, along with the assembly name, version number, and culture information.
            This flag is set when the strong name signing procedure is applied to the image file.
            No compiler, including ILAsm, can set this flag explicity.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS.NATIVE_ENTRYPOINT">
            <remarks>
            The executable's entry point is an unmanaged method.
            The EntryPointToken/EntryPointRVA field of CLR header contains the RVA of this native method.
            This flag was introduced in version 2.0 of the CLR.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COMIMAGE_FLAGS.TRACKDEBUGDATA">
            <summary>
            The CLR loader and the JIT compiler are required to track debug information about the methods.
            This flag is not used.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_FILE">
            <summary>The characteristics of the image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.RELOCS_STRIPPED">
            <summary>
            Image only, Windows CE, and Windows NT® and later.
            This indicates that the file does not contain base relocations and must therefore be loaded at its preferred base address.
            If the base address is not available, the loader reports an error.
            The default behavior of the linker is to strip base relocations from executable (EXE) files.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.EXECUTABLE_IMAGE">
            <summary>
            Image only. This indicates that the image file is valid and can be run.
            If this flag is not set, it indicates a linker error.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.LINE_NUMS_STRIPPED">
            <summary>COFF line numbers have been removed. This flag is deprecated and should be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.LOCAL_SYMS_STRIPPED">
            <summary>COFF symbol table entries for local symbols have been removed. This flag is deprecated and should be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.AGGRESIVE_WS_TRIM">
            <summary>Obsolete. Aggressively trim working set. This flag is deprecated for Windows 2000 and later and must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.LARGE_ADDRESS_AWARE">
            <summary>Application can handle > 2 GB addresses.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.Reserved1">
            <summary>This flag is reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.BYTES_REVERSED_LO">
            <summary>Little endian: the least significant bit (LSB) precedes the most significant bit (MSB) in memory. This flag is deprecated and should be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE._32BIT_MACHINE">
            <summary>Machine is based on a 32-bit-word architecture.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.DEBUG_STRIPPED">
            <summary>Debugging information is removed from the image file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.REMOVABLE_RUN_FROM_SWAP">
            <summary>If the image is on removable media, fully load it and copy it to the swap file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.NET_RUN_FROM_SWAP">
            <summary>If the image is on network media, fully load it and copy it to the swap file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.SYSTEM">
            <summary>The image file is a system file, not a user program.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.DLL">
            <summary>The image file is a dynamic-link library (DLL). Such files are considered executable files for almost all purposes, although they cannot be directly run.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.UP_SYSTEM_ONLY">
            <summary>The file should be run only on a uniprocessor machine.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE.BYTES_REVERSED_HI">
            <summary>Big endian: the MSB precedes the LSB in memory. This flag is deprecated and should be zero.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY">
            <summary>NT Directory types</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.EXPORT">
            <summary>The export table address and size.</summary>
            <remarks>Points to the exports (an <see cref="T:IMAGE_EXPORT_DIRECTORY"/> structure).</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.IMPORT">
            <summary>The import table address and size.</summary>
            <remarks>Points to the imports (an array of <see cref="T:IMAGE_IMPORT_DESCRIPTOR"/> structures).</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.RESOURCE">
            <summary>The resource table address and size.</summary>
            <remarks>Points to the resources (an <see cref="T:IMAGE_RESOURCE_DIRECTORY"/> structure).</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.EXCEPTION">
            <summary>The exception table address and size.</summary>
            <remarks>
            Points to the exception handler table (an array of <see cref="T:IMAGE_RUNTIME_FUNCTION_ENTRY"/> structures).
            CPU-specific and for table-based exception handling. Used on every CPU except the x86.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.CERTIFICATE">
            <summary>The attribute certificate table address and size.</summary>
            <remarks>
            Points to a list of <see cref="T:WIN_CERTIFICATE"/> structures, defined in WinTrust.H.
            Not mapped into memory as part of the image. Therefore, the VirtualAddress field is a file offset, rather than an RVA.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.BASERELOC">
            <summary>The base relocation table address and size.</summary>
            <remarks>Points to the base relocation information.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.DEBUG">
            <summary>The debug data starting address and size.</summary>
            <remarks>
            Points to an array of <see cref="T:IMAGE_DEBUG_DIRECTORY"/> structures, each describing some debug information for the image.
            Early Borland linkers set the Size field of this <see cref="T:IMAGE_DATA_DIRECTORY"/> entry to the number of structures, rather than the size in bytes. To get the number of <see cref="T:IMAGE_DEBUG_DIRECTORY"/>s, divide the Size field by the size of an <see cref="T:IMAGE_DEBUG_DIRECTORY"/>.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.ARCHITECTURE">
            <summary>Reserved, must be 0</summary>
            <remarks>
            Points to architecture-specific data, which is an array of IMAGE_ARCHITECTURE_HEADER structures.
            Not used for x86 or IA-64, but appears to have been used for DEC/Compaq Alpha.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.GLOBALPTR">
            <summary>
            The RVA of the value to be stored in the global pointer register.
            The size member of this structure must be set to zero.
            </summary>
            <remarks>
            The VirtualAddress field is the RVA to be used as the global pointer (gp) on certain architectures.
            Not used on x86, but is used on IA-64. The Size field isn't used.
            See the November 2000 Under The Hood column for more information on the IA-64 gp.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.TLS">
            <summary>The thread local storage (TLS) table address and size.</summary>
            <remarks>Points to the Thread Local Storage initialization section.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.LOAD_CONFIG">
            <summary>The load configuration table address and size.</summary>
            <remarks>
            Points to an IMAGE_LOAD_CONFIG_DIRECTORY structure.
            The information in an IMAGE_LOAD_CONFIG_DIRECTORY is specific to Windows NT, Windows 2000, and Windows XP (for example, the GlobalFlag value).
            To put this structure in your executable, you need to define a global structure with the name __load_config_used, and of type IMAGE_LOAD_CONFIG_DIRECTORY.
            For non-x86 architectures, the symbol name needs to be _load_config_used (with a single underscore).
            If you do try to include an IMAGE_LOAD_CONFIG_DIRECTORY, it can be tricky to get the name right in your C++ code.
            The symbol name that the linker sees must be exactly: __load_config_used (with two underscores).
            The C++ compiler adds an underscore to global symbols.
            In addition, it decorates global symbols with type information.
            So, to get everything right, in your C++ code, you'd have something like this: extern "C" IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {...}
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.BOUND_IMPORT">
            <summary>The bound import table address and size.</summary>
            <remarks>
            Points to an array of <see cref="T:IMAGE_BOUND_IMPORT_DESCRIPTOR"/>s, one for each DLL that this image has bound against.
            The timestamps in the array entries allow the loader to quickly determine whether the binding is fresh.
            If stale, the loader ignores the binding information and resolves the imported APIs normally.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.IAT">
            <summary>The import address table address and size.</summary>
            <remarks>
            Points to the beginning of the first Import Address Table (IAT).
            The IATs for each imported DLL appear sequentially in memory.
            The Size field indicates the total size of all the IATs.
            The loader uses this address and size to temporarily mark the IATs as read-write during import resolution.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.DELAY_IMPORT">
            <summary>The delay import descriptor address and size.</summary>
            <remarks>
            Points to the delayload information, which is an array of <see cref="T:ImgDelayDescr"/> structures, defined in DELAYIMP.H from Visual C++.
            Delayloaded DLLs aren't loaded until the first call to an API in them occurs.
            It's important to note that Windows has no implicit knowledge of delay loading DLLs.
            The delayload feature is completely implemented by the linker and runtime library.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY.CLR_HEADER">
            <summary>The CLR runtime header address and size.</summary>
            <remarks>
            This value has been renamed to IMAGE_DIRECTORY_ENTRY_COMHEADER in more recent updates to the system header files.
            It points to the top-level information for .NET information in the executable, including metadata.
            This information is in the form of an <see cref="T:IMAGE_COR20_HEADER"/> structure.
            </remarks>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY">
            <summary>.NET Directory types</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.Resources">
            <summary>The RVA and size of the .NET resources.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.StrongNameSignature">
            <summary>The RVA of the strong name hash data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.CodeManagerTable">
            <summary>
            The RVA of the code manager table.
            A code manager contains the code required to obtain the state of a running program (such as tracing the stack and track GC references).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.VTableFuxups">
            <summary>
            The RVA of an array of function pointers that need fixups.
            This is for support of unmanaged C++ vtables.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.ExportAddressTableJumps">
            <summary>
            The RVA to an array of RVAs where export JMP thunks are written.
            These thunks allow managed methods to be exported so that unmanaged code can call them.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.ManagedNativeHeaer">
            <summary>For internal use of the .NET runtime in memory. Set to 0 in the executable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY.MetaData">
            <summary>
            The RVA to the metadata tables.
            Symbol table and startup information.</summary>
            <remarks>Pointer to <see cref="T:IMAGE_COR20_METADATA"/> section.</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_SCN">
            <summary>Image section characteristics</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_REG">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_DSECT">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_NOLOAD">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_GROUP">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_NO_PAD">
            <summary>
            The section should not be padded to the next boundary.
            This flag is obsolete and is replaced by <see cref="T:IMAGE_SCN_ALIGN_1BYTES"/>.
            This is valid only for object files.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_COPY">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.CNT_CODE">
            <summary>The section contains executable code.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.CNT_INITIALIZED_DATA">
            <summary>The section contains initialized data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.CNT_UNINITIALIZED_DATA">
            <summary>The section contains uninitialized data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.LNK_OTHER">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.LNK_INFO">
            <summary>The section contains comments or other information. The .drectve section has this type. This is valid for object files only.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.TYPE_OVER">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.LNK_REMOVE">
            <summary>The section will not become part of the image. This is valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.LNK_COMDAT">
            <summary>The section contains COMDAT data. For more information, see section 5.5.6, COMDAT Sections (Object Only). This is valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.NO_DEFER_SPEC_EXC">
            <summary>Reset speculative exceptions handling bits in the TLB entries for this section.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_FARDATA">
            <summary>The section contains data referenced through the global pointer (GP).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_SYSHEAP">
            <summary>Obsolete</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_PURGEABLE">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_16BIT">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_LOCKED">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_PRELOAD">
            <summary>Reserved for future use.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_1BYTES">
            <summary>Align data on a 1-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_2BYTES">
            <summary>Align data on a 2-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_4BYTES">
            <summary>Align data on a 4-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_8BYTES">
            <summary>Align data on an 8-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_16BYTES">
            <summary>Align data on a 16-byte boundary. Valid only for object files.</summary>
            <remarks>Default alignment if no others are specified.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_32BYTES">
            <summary>Align data on a 32-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_64BYTES">
            <summary>Align data on a 64-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_128BYTES">
            <summary>Align data on a 128-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_256BYTES">
            <summary>Align data on a 256-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_512BYTES">
            <summary>Align data on a 512-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_1024BYTES">
            <summary>Align data on a 1024-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_2048BYTES">
            <summary>Align data on a 2048-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_4096BYTES">
            <summary>Align data on a 4096-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_8192BYTES">
            <summary>Align data on an 8192-byte boundary. Valid only for object files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.ALIGN_MASK">
            <summary>Mask?</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.LNK_NRELOC_OVFL">
            <summary>The section contains extended relocations.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_DISCARDABLE">
            <summary>The section can be discarded from the final executable. Used to hold information for the linker's use, including the .debug$ sections.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_NOT_CACHED">
            <summary>The section cannot be cached.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_NOT_PAGED">
            <summary>The section is not pageable, so it should always be physically present in memory. Often used for kernel-mode drivers.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_SHARED">
            <summary>
            The physical pages containing this section's data will be shared between all processes that have this executable loaded.
            Thus, every process will see the exact same values for data in this section.
            Useful for making global variables shared between all instances of a process.
            To make a section shared, use the /section:name,S linker switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_EXECUTE">
            <summary>The section can be executed as code.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_READ">
            <summary>The section is readable. Almost always set.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SCN.MEM_WRITE">
            <summary>The section can be written to.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.WIN_CERT_REVISION">
            <summary>Certificate revision number type</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_REVISION.REVISION_1_0">
            <summary>
            Version 1, legacy version of the Win_Certificate structure.
            It is supported only for purposes of verifying legacy Authenticode signatures.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_REVISION.REVISION_2_0">
            <summary>Version 2 is the current version of the Win_Certificate structure.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE">
            <summary>Specifies the type of certificate.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE.X509">
            <summary>bCertificate contains an X.509 Certificate. Not supported.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE.PKCS_SIGNED_DATA">
            <summary>bCertificate contains a PKCS#7 SignedData structure</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE.RESERVED_1">
            <summary>Reserved</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE.TS_STACK_SIGNED">
            <summary>Terminal Server Protocol Stack Certificate signing.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERT_TYPE.PKCS1_SIGN">
            <summary>bCertificate contains PKCS1_MODULE_SIGN fields.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.DLAttr">
            <summary>Delay Load Attributes</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.DLAttr.Va">
            <summary>Virtual Addresses used</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.DLAttr.Rva">
            <summary>RVAs are used instead of pointers Having this set indicates a VC7.0 and above delay load descriptor.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED">
            <summary>Based relocation types</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.ABSOLUTE">
            <summary>The base relocation is skipped. This type can be used to pad a block.</summary>
            <remarks>
            You will often see a relocation of type IMAGE_REL_BASED_ABSOLUTE at the end of a group of relocations.
            These relocations do nothing, and are there just to pad things so that the next IMAGE_BASE_RELOCATION is aligned on a 4-byte boundary.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.HIGH">
            <summary>
            The base relocation adds the high 16 bits of the difference to the 16-bit field at offset.
            The 16-bit field represents the high value of a 32-bit word.
            </summary>
            <remarks>
            We must assume that high and low fixups occur in pairs,
            specifically a low fixup immediately follows a high fixup (normally separated by two bytes).
            We have to process the two fixups together,
            to find out the full pointer value and decide whether to apply the fixup.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.LOW">
            <summary>
            The base relocation adds the low 16 bits of the difference to the 16-bit field at offset.
            The 16-bit field represents the low half of a 32-bit word.
            </summary>
            <remarks>Unless our assumption is wrong, all low word fixups should immediately follow a high fixup.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.HIGHLOW">
            <summary>The base relocation applies all 32 bits of the difference to the 32-bit field at offset.</summary>
            <remarks>
            For x86 executables, all base relocations are of type IMAGE_REL_BASED_HIGHLOW.
            Docs imply two words in big-endian order, so perhaps this is only used on big-endian platforms,
            in which case the obvious code will work.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.HIGHADJ">
            <summary>
            The base relocation adds the high 16 bits of the difference to the 16-bit field at offset.
            The 16-bit field represents the high value of a 32-bit word.
            The low 16 bits of the 32-bit value are stored in the 16-bit word that follows this base relocation.
            This means that this base relocation occupies two slots.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.MIPS_JMPADDR">
            <summary>For MIPS machine types, the base relocation applies to a MIPS jump instruction.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.ARM_MOV32A">
            <summary>For ARM machine types, the base relocation applies the difference to the 32-bit value encoded in the immediate fields of a contiguous MOVW+MOVT pair in ARM mode at offset.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.RES1">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.ARM_MOV32T">
            <summary>The base relocation applies the difference to the 32-bit value encoded in the immediate fields of a contiguous MOVW+MOVT pair in Thumb mode at offset.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.MIPS_JMPADDR16">
            <summary>The base relocation applies to a MIPS16 jump instruction.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.DIR64">
            <summary>
            The fixup adds the high 16 bits of the delta to the 16-bit field at the offset.
            The 16-bit field is the high one-third of a 48-bit address.
            The low 32 bits of the address are stored in the 32-bit double word that follows this relocation.
            A fixup of this type occupies three slots.
            </summary>
            <remarks>For IA-64 executables, the relocations seem to always be of type IMAGE_REL_BASED_DIR64.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_REL_BASED.HIGH3ADJ">
            <summary>
            Similar to IMAGE_REL_BASED_HIGHADJ except this is the third word.
            Adjust low half of high ULONG of an address and adjust for sign extension of the low ULONG.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER">
            <summary>PE Dos header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_magic">
            <summary>Magic number</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_cblp">
            <summary>Bytes on last page of file</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_cp">
            <summary>Pages in file</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_crlc">
            <summary>Relocations</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_cparhdr">
            <summary>Size of header in paragraphs</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_minalloc">
            <summary>Minimum extra paragraphs needed</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_maxalloc">
            <summary>Maximum extra paragraphs needed</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_ss">
            <summary>Initial (relative) SS value</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_sp">
            <summary>Initial SP value</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_csum">
            <summary>Checksum</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_ip">
            <summary>Initial IP value</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_cs">
            <summary>Initial (relative) CS value</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_lfarlc">
            <summary>File address of relocation table</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_ovno">
            <summary>Overlay number</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_res1">
            <summary>Reserved words</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_oemid">
            <summary>OEM identifier (for e_oeminfo)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_oeminfo">
            <summary>OEM information; e_oemid specific</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_res2">
            <summary>Reserved words</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.e_lfanew">
            <summary>File address of new exe header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.SignatureStr">
            <summary>String representation fo signature field</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_DOS_HEADER.IsValid">
            <summary>Dos header is valid</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER">
            <summary>Represents the COFF header format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.Machine">
            <summary>
            The architecture type of the computer.
            An image file can only be run on the specified computer or a system that emulates the specified computer.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.NumberOfSections">
            <summary>The number of sections. This indicates the size of the section table, which immediately follows the headers. Note that the Windows loader limits the number of sections to 96.</summary>
            <remarks>The section table immediately follows the IMAGE_NT_HEADERS.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.TimeDateStamp">
            <summary>
            The low 32 bits of the time stamp of the image.
            This represents the date and time the image was created by the linker.
            The value is represented in the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Universal Coordinated Time, according to the system clock.
            </summary>
            <remarks>
            This value is the number of seconds since January 1, 1970, Greenwich Mean Time (GMT).
            This value is a more accurate indicator of when the file was created than is the file system date/time.
            An easy way to translate this value into a human-readable string is with the _ctime function (which is time-zone-sensitive!).
            Another useful function for working with this field is gmtime.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.PointerToSymbolTable">
            <summary>
            The file offset of the COFF symbol table, described in section 5.4 of the Microsoft specification.
            COFF symbol tables are relatively rare in PE files, as newer debug formats have taken over.
            Prior to Visual Studio .NET, a COFF symbol table could be created by specifying the linker switch /DEBUGTYPE:COFF.
            COFF symbol tables are almost always found in OBJ files. Set to 0 if no symbol table is present.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.NumberOfSymbols">
            <summary>
            Number of symbols in the COFF symbol table, if present.
            COFF symbols are a fixed size structure, and this field is needed to find the end of the COFF symbols.
            Immediately following the COFF symbols is a string table used to hold longer symbol names.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.SizeOfOptionalHeader">
            <summary>
            The size of the optional data that follows the <see cref="T:IMAGE_FILE_HEADER"/>.
            In PE files, this data is the IMAGE_OPTIONAL_HEADER.
            This size is different depending on whether it's a 32 or 64-bit file.
            For 32-bit PE files, this field is usually 224. For 64-bit PE32+ files, it's usually 240.
            However, these sizes are just minimum values, and larger values could appear.
            This value should be 0 for object files.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.Characteristics">
            <summary>
            A set of bit flags indicating attributes of the file.
            Valid values of these flags are the <see cref="T:IMAGE_FILE"/> values defined in WINNT.H.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.TimeDate">
            <summary>This value is a more accurate indicator of when the file was created than is the file system date/time.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_FILE_HEADER.ContainsSymbolTable">
            <summary>File contains COFF symbol table.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER">
            <summary>Represents the COFF symbols header.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms680301(v=vs.85).aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.NumberOfSymbols">
            <summary>The number of symbols.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.LvaToFirstSymbol">
            <summary>The virtual address of the first symbol.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.NumberOfLinenumbers">
            <summary>The number of line-number entries.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.LvaToFirstLinenumber">
            <summary>The virtual address of the first line-number entry.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.RvaToFirstByteOfCode">
            <summary>The relative virtual address of the first byte of code.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.RvaToLastByteOfCode">
            <summary>The relative virtual address of the last byte of code.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.RvaToFirstByteOfData">
            <summary>The relative virtual address of the first byte of data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COFF_SYMBOLS_HEADER.RvaToLastByteOfData">
            <summary>The relative virtual address of the last byte of data.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER">
            <summary>Represents the image section header format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.Name">
            <summary>
            The ASCII name of the section.
            A section name is not guaranteed to be null-terminated.
            If you specify a section name longer than eight characters, the linker truncates it to eight characters in the executable.
            A mechanism exists for allowing longer section names in OBJ files.
            Section names often start with a period, but this is not a requirement.
            Section names with a $ in the name get special treatment from the linker.
            Sections with identical names prior to the $ character are merged.
            The characters following the $ provide an alphabetic ordering for how the merged sections appear in the final section.
            There's quite a bit more to the subject of sections with $ in the name and how they're combined, but the details are outside the scope of this article.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.VirtualSize">
            <summary>
            Indicates the actual, used size of the section.
            This field may be larger or smaller than the SizeOfRawData field.
            If the VirtualSize is larger, the SizeOfRawData field is the size of the initialized data from the executable, and the remaining bytes up to the VirtualSize should be zero-padded.
            This field is set to 0 in OBJ files.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.VirtualAddress">
            <summary>In executables, indicates the RVA where the section begins in memory. Should be set to 0 in OBJs.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.SizeOfRawData">
            <summary>
            The size (in bytes) of data stored for the section in the executable or OBJ.
            For executables, this must be a multiple of the file alignment given in the PE header.
            If set to 0, the section is uninitialized data.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.PointerToRawData">
            <summary>
            The file offset where the data for the section begins.
            For executables, this value must be a multiple of the file alignment given in the PE header.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.PointerToRelocations">
            <summary>
            The file offset of relocations for this section.
            This is only used in OBJs and set to zero for executables.
            In OBJs, it points to an array of IMAGE_RELOCATION structures if non-zero.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.PointerToLinenumbers">
            <summary>
            The file offset for COFF-style line numbers for this section.
            Points to an array of IMAGE_LINENUMBER structures if non-zero. Only used when COFF line numbers are emitted.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.NumberOfRelocations">
            <summary>
            The number of relocations pointed to by the PointerToRelocations field.
            Should be 0 in executables.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.NumberOfLinenumbers">
            <summary>
            The number of line numbers pointed to by the NumberOfRelocations field.
            Only used when COFF line numbers are emitted.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.Characteristics">
            <summary>
            Flags OR'ed together, indicating the attributes of this section.
            Many of these flags can be set with the linker's /SECTION option.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_SECTION_HEADER.Section">
            <summary>
            The ASCII name of the section.
            A section name is not guaranteed to be null-terminated.
            If you specify a section name longer than eight characters, the linker truncates it to eight characters in the executable.
            A mechanism exists for allowing longer section names in OBJ files.
            Section names often start with a period, but this is not a requirement.
            Section names with a $ in the name get special treatment from the linker.
            Sections with identical names prior to the $ character are merged.
            The characters following the $ provide an alphabetic ordering for how the merged sections appear in the final section.
            There's quite a bit more to the subject of sections with $ in the name and how they're combined, but the details are outside the scope of this article.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY">
            <summary>Represents the debug directory format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.Characteristics">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.TimeDateStamp">
            <summary>The time and date that the debug data was created.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.MajorVersion">
            <summary>The major version number of the debugging information format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.MinorVersion">
            <summary>The minor version number of the debugging information format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.Type">
            <summary>The format of debugging information. This field enables support of multiple debuggers. For more information, see section 6.1.2, "Debug Type".</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.SizeOfData">
            <summary>The size of the debug data (not including the debug directory itself).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.AddressOfRawData">
            <summary>The address of the debug data when loaded, relative to the image base.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.PointerToRawData">
            <summary>The file pointer to the debug data.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.TimeDate">
            <summary>The time and date that the debug data was created.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_DEBUG_DIRECTORY.Version">
            <summary>Version number of the debugging information format</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource">
            <summary>Native Resource directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY">
            <summary>Resource directory</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.Characteristics">
            <summary>Unused</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.TimeDateStamp">
            <summary>Unused</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.MajorVersion">
            <summary>Major directory version</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.MinorVersion">
            <summary>Minor directory version</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.NumberOfNamedEntries">
            <summary>Number of subdirectories with names</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.NumberOfIdEntries">
            <summary>Number of subdirectories with IDs</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.TimeDate">
            <summary>Unused</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.Version">
            <summary>Directory version</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.ContainsEntries">
            <summary>Contains subdirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY.NumberOfEntries">
            <summary>Number of subdirectories</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY">
            <summary>Resource directory description</summary>
            <remarks>
            Each directory contains the 32-bit Name of the entry and an offset,
            relative to the beginning of the resource directory of the data associated
            with this directory entry. If the name of the entry is an actual text
            string instead of an integer Id, then the high order bit of the name field
            is set to one and the low order 31-bits are an offset, relative to the
            beginning of the resource directory of the string, which is of type <see cref="T:IMAGE_RESOURCE_DIRECTORY_STRING"/>.
            Otherwise the high bit is clear and the low-order 16-bits are the integer Id that identify this resource directory
            entry. If the directory entry is yet another resource directory (i.e. a
            subdirectory), then the high order bit of the offset field will be
            set to indicate this. Otherwise the high bit is clear and the offset field points to a resource data entry.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.NameOffset">
            <summary>Directory name offset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.OffsetToData">
            <summary>Directory data offset</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.IsNameString">
            <summary>Directory name is string</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.NameAddress">
            <summary>Адрес на структуру <see cref="T:IMAGE_RESOURCE_DIRECTORY_STRING"/> или идентификатор папки.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.NameType">
            <summary>Тип корневой директории</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.IsDirectory">
            <summary>Entry is directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.DirectoryAddress">
            <summary>Адрес на <see cref="T:IMAGE_RESOURCE_DIRECTORY"/> или на <see cref="T:WinNT.IMAGE_RESOURCE_DATA_ENTRY"/></summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY.IsDataEntry">
            <summary>Адрес на структуру <see cref="T:WinNT.IMAGE_RESOURCE_DATA_ENTRY"/></summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE">
            <summary>The following are the predefined resource types.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.Undefined">
            <summary>Undefined</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_CURSOR">
            <summary>Hardware-dependent cursor resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_BITMAP">
            <summary>Bitmap resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_ICON">
            <summary>Hardware-dependent icon resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_MENU">
            <summary>Menu resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_DIALOG">
            <summary>Dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_STRING">
            <summary>String-table entry.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_FONTDIR">
            <summary>Font directory resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_FONT">
            <summary>Font resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_ACCELERATOR">
            <summary>Accelerator table.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_RCDATA">
            <summary>Application-defined resource (raw data).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_MESSAGETABLE">
            <summary>Message-table entry.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_GROUP_CURSOR2">
            <summary>Hardware-independent cursor resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_GROUP_CURSOR4">
            <summary>Hardware-independent cursor resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_VERSION">
            <summary>Version resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_DLGINCLUDE">
            <summary>
            Allows a resource editing tool to associate a string with an .rc file.
            Typically, the string is the name of the header file that provides symbolic names.
            The resource compiler parses the string but otherwise ignores the value.
            For example, 1 DLGINCLUDE "MyFile.h"
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_PLUGPLAY">
            <summary>Plug and Play resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_VXD">
            <summary>VXD.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_ANICURSOR">
            <summary>Animated cursor.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_ANIICON">
            <summary>Animated icon.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_HTML">
            <summary>HTML resource.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_MANIFEST">
            <summary>Side-by-Side Assembly Manifest.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_DLGINIT">
            <summary>MFC CDialog</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE.RT_TOOLBAR">
            <summary>MFC CToolBarCtrl</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DATA_ENTRY">
            <summary></summary>
            <remarks>
            Each resource data entry describes a leaf node in the resource directory tree.
            It contains an offset, relative to the beginning of the resource
            directory of the data for the resource, a size field that gives the number
            of bytes of data at that offset, a CodePage that should be used when
            decoding code point values within the resource data.
            Typically for new applications the code page would be the unicode code page.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DATA_ENTRY.OffsetToData">
            <summary>
            The OffsetToData and Size fields specify the location (as a relative virtual address within the resource section) and size (in bytes) of the resource data.
            Although an RVA is not the same as a file offset, the equivalent file offset can be calculated by subtracting the resource section's RVA from OffsetToData's RVA value, and adding the difference to the offset of the root directory.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DATA_ENTRY.Size">
            <summary>Size of resource directory</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DATA_ENTRY.CodePage">
            <summary>
            The CodePage field identifies the code page (a coded character set) used to decode code points (code page values) within the resource data.
            Although any valid code page number can appear in this field (such as 437, which describes the original IBM PC's character set, or 65501, which describes Unicode UTF-8),
            this field often contains 0 (standard Roman alphabet, numerals, punctuation, accented characters).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DATA_ENTRY.Reserved">
            <summary>Reserved. Must be zero.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_STRING">
            <summary>Directory name</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_STRING.Length">
            <summary>Name length</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_STRING.NameString">
            <summary>Name string</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_STRING.Name">
            <summary>NameString может закончится НЕ \0. Поэтому правильно отрезать лишнюю информацию</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY">
            <summary>Describes the data in an individual accelerator table resource. The structure definition provided here is for explanation only; it is not present in any standard header file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY.fFlags">
            <summary>Describes keyboard accelerator characteristics. This member can have one or more of the following values from Winuser.h. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY.wAnsi">
            <summary>An ANSI character value or a virtual-key code that identifies the accelerator key. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY.wId">
            <summary>An identifier for the keyboard accelerator. This is the value passed to the window procedure when the user presses the specified key. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY.padding">
            <summary>The number of bytes inserted to ensure that the structure is aligned on a DWORD boundary. </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.ACCELTABLEENTRY.StringKey">
            <summary>Получить строковое представление wAnsi параметра</summary>
            <remarks>Для получения строкового представления используются Win32 вызовы</remarks>
            <exception cref="T:Win32Exception">Can't convert Key code to text key name</exception>
            <returns>Строковое представление параметра</returns>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.AccelFlags">
            <summary>Describes keyboard accelerator characteristics.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.FVIRTKEY">
            <summary>The accelerator key is a virtual-key code. If this flag is not specified, the accelerator key is assumed to specify an ASCII character code. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.FNOINVERT">
            <summary>A menu item on the menu bar is not highlighted when an accelerator is used. This attribute is obsolete and retained only for backward compatibility with resource files designed for 16-bit Windows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.FSHIFT">
            <summary>The accelerator is activated only if the user presses the SHIFT key. This flag applies only to virtual keys. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.FCONTROL">
            <summary>The accelerator is activated only if the user presses the CTRL key. This flag applies only to virtual keys. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.FALT">
            <summary>The accelerator is activated only if the user presses the ALT key. This flag applies only to virtual keys. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.AccelFlags.Last">
            <summary>The entry is last in an accelerator table. </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE">
            <summary>
            Defines the dimensions and style of a dialog box.
            This structure, always the first in a standard template for a dialog box, also specifies the number of controls in the dialog box and therefore specifies the number of subsequent DLGITEMTEMPLATE structures in the template.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms645394%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.style">
            <summary>
            The style of the dialog box. This member can be a combination of window style values (such as WS_CAPTION and WS_SYSMENU) and dialog box style values (such as DS_CENTER).
            If the style member includes the DS_SETFONT style, the header of the dialog box template contains additional data specifying the font to use for text in the client area and controls of the dialog box. The font data begins on the WORD boundary that follows the title array. The font data specifies a 16-bit point size value and a Unicode font name string. If possible, the system creates a font according to the specified values. Then the system sends a WM_SETFONT message to the dialog box and to each control to provide a handle to the font. If DS_SETFONT is not specified, the dialog box template does not include the font data.
            The DS_SHELLFONT style is not supported in the DLGTEMPLATE header.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.dwExtendedStyle">
            <summary>The extended styles for a window. This member is not used to create dialog boxes, but applications that use dialog box templates can use it to create other types of windows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.cdit">
            <summary>The number of items in the dialog box. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.x">
            <summary>The x-coordinate, in dialog box units, of the upper-left corner of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.y">
            <summary>The y-coordinate, in dialog box units, of the upper-left corner of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.cx">
            <summary>The width, in dialog box units, of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.cy">
            <summary>The height, in dialog box units, of the dialog box.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATE.ContainsFont">
            <summary>В структуре присутсвует информация по шрифту</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE">
            <summary>
            Defines the dimensions and style of a control in a dialog box.
            One or more of these structures are combined with a DLGTEMPLATE structure to form a standard template for a dialog box.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms644997%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.style">
            <summary>The style of the control. This member can be a combination of window style values (such as WS_BORDER) and one or more of the control style values (such as BS_PUSHBUTTON and ES_LEFT).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.dwExtendedStyle">
            <summary>The extended styles for a window. This member is not used to create controls in dialog boxes, but applications that use dialog box templates can use it to create other types of windows. For a list of values, see Extended Window Styles.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.x">
            <summary>The x-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative to the upper-left corner of the dialog box's client area.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.y">
            <summary>The y-coordinate, in dialog box units, of the upper-left corner of the control. This coordinate is always relative to the upper-left corner of the dialog box's client area.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.cx">
            <summary>The width, in dialog box units, of the control.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.cy">
            <summary>The height, in dialog box units, of the control.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATE.id">
            <summary>The control identifier.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX">
            <summary>
            An extended dialog box template begins with a DLGTEMPLATEEX header that describes the dialog box and specifies the number of controls in the dialog box.
            For each control in a dialog box, an extended dialog box template has a block of data that uses the DLGITEMTEMPLATEEX format to describe the control.
            The DLGTEMPLATEEX structure is not defined in any standard header file.
            The structure definition is provided here to explain the format of an extended template for a dialog box.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms645398%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.dlgVer">
            <summary>The version number of the extended dialog box template. This member must be set to 1. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.signature">
            <summary>
            Indicates whether a template is an extended dialog box template.
            If signature is 0xFFFF, this is an extended dialog box template.
            In this case, the dlgVer member specifies the template version number.
            If signature is any value other than 0xFFFF, this is a standard dialog box template that uses the DLGTEMPLATE and DLGITEMTEMPLATE structures.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.helpID">
            <summary>The help context identifier for the dialog box window. When the system sends a WM_HELP message, it passes this value in the wContextId member of the HELPINFO structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.exStyle">
            <summary>
            The extended windows styles.
            This member is not used when creating dialog boxes, but applications that use dialog box templates can use it to create other types of windows.
            For a list of values, see Extended Window Styles.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.style">
            <summary>
            The style of the dialog box. This member can be a combination of window style values and dialog box style values.
            </summary>
            <remarks>
            If style includes the DS_SETFONT or DS_SHELLFONT dialog box style, the DLGTEMPLATEEX header of the extended dialog box template contains four additional members ( pointsize, weight, italic, and typeface) that describe the font to use for the text in the client area and controls of the dialog box. If possible, the system creates a font according to the values specified in these members.
            Then the system sends a WM_SETFONT message to the dialog box and to each control to provide a handle to the font.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.cDlgItems">
            <summary>The number of controls in the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.x">
            <summary>The x-coordinate, in dialog box units, of the upper-left corner of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.y">
            <summary>The y-coordinate, in dialog box units, of the upper-left corner of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.cx">
            <summary>The width, in dialog box units, of the dialog box.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.cy">
            <summary>The height, in dialog box units, of the dialog box.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.IsValid">
            <summary>Valid template</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.DLGTEMPLATEEX.ContainsFont">
            <summary>В структуре присутсвует информация по шрифту</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX">
            <summary>
            A block of text used by an extended dialog box template to describe the extended dialog box.
            For a description of the format of an extended dialog box template, see DLGTEMPLATEEX.
            </summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms645389%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.helpID">
            <summary>The help context identifier for the control. When the system sends a WM_HELP message, it passes the helpID value in the dwContextId member of the HELPINFO structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.exStyle">
            <summary>
            The extended styles for a window.
            This member is not used to create controls in dialog boxes, but applications that use dialog box templates can use it to create other types of windows.
            </summary>
            <remarks>For a list of values, see Extended Window Styles.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.style">
            <summary>
            The style of the control.
            This member can be a combination of window style values (such as WS_BORDER) and one or more of the control style values (such as BS_PUSHBUTTON and ES_LEFT).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.x">
            <summary>
            The x-coordinate, in dialog box units, of the upper-left corner of the control.
            This coordinate is always relative to the upper-left corner of the dialog box's client area.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.y">
            <summary>
            The y-coordinate, in dialog box units, of the upper-left corner of the control.
            This coordinate is always relative to the upper-left corner of the dialog box's client area.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.cx">
            <summary>The width, in dialog box units, of the control.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.cy">
            <summary>The height, in dialog box units, of the control.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.DLGITEMTEMPLATEEX.id">
            <summary>The control identifier.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.WS">
            <summary>The following are the window styles. After the window has been created, these styles cannot be modified, except as noted.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_OVERLAPPED">
            <summary>The window is an overlapped window. An overlapped window has a title bar and a border. Same as the WS_TILED style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_BORDER">
            <summary>The window has a thin-line border.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_CAPTION">
            <summary>The window has a title bar (includes the WS_BORDER style).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_CHILD">
            <summary>The window is a child window. A window with this style cannot have a menu bar. This style cannot be used with the WS_POPUP style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_CLIPCHILDREN">
            <summary>Excludes the area occupied by child windows when drawing occurs within the parent window. This style is used when creating the parent window.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_CLIPSIBLINGS">
            <summary>Clips child windows relative to each other; that is, when a particular child window receives a WM_PAINT message, the WS_CLIPSIBLINGS style clips all other overlapping child windows out of the region of the child window to be updated. If WS_CLIPSIBLINGS is not specified and child windows overlap, it is possible, when drawing within the client area of a child window, to draw within the client area of a neighboring child window.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_DISABLED">
            <summary>The window is initially disabled. A disabled window cannot receive input from the user. To change this after a window has been created, use the EnableWindow function.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_DLGFRAME">
            <summary>The window has a border of a style typically used with dialog boxes. A window with this style cannot have a title bar.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_GROUP">
            <summary>
            The window is the first control of a group of controls. The group consists of this first control and all controls defined after it, up to the next control with the WS_GROUP style. The first control in each group usually has the WS_TABSTOP style so that the user can move from group to group. The user can subsequently change the keyboard focus from one control in the group to the next control in the group by using the direction keys.
            You can turn this style on and off to change dialog box navigation. To change this style after a window has been created, use the SetWindowLong function.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_HSCROLL">
            <summary>The window has a horizontal scroll bar.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_MAXIMIZE">
            <summary>The window is initially maximized.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_MAXIMIZEBOX">
            <summary>The window has a maximize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_MINIMIZE">
            <summary>The window is initially minimized. Same as the WS_ICONIC style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_MINIMIZEBOX">
            <summary>The window has a minimize button. Cannot be combined with the WS_EX_CONTEXTHELP style. The WS_SYSMENU style must also be specified.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_OVERLAPPEDWINDOW">
            <summary>The window is an overlapped window. Same as the WS_TILEDWINDOW style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_POPUP">
            <summary>The windows is a pop-up window. This style cannot be used with the WS_CHILD style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_POPUPWINDOW">
            <summary>The window is a pop-up window. The WS_CAPTION and WS_POPUPWINDOW styles must be combined to make the window menu visible.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_SYSMENU">
            <summary>The window has a window menu on its title bar. The WS_CAPTION style must also be specified.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_TABSTOP">
            <summary>
            The window is a control that can receive the keyboard focus when the user presses the TAB key. Pressing the TAB key changes the keyboard focus to the next control with the WS_TABSTOP style.
            You can turn this style on and off to change dialog box navigation. To change this style after a window has been created, use the SetWindowLong function. For user-created windows and modeless dialogs to work with tab stops, alter the message loop to call the IsDialogMessage function.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_THICKFRAME">
            <summary>The window has a sizing border. Same as the WS_SIZEBOX style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_TILEDWINDOW">
            <summary>The window is an overlapped window. Same as the WS_OVERLAPPEDWINDOW style.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_VISIBLE">
            <summary>
            The window is initially visible.
            This style can be turned on and off by using the ShowWindow or SetWindowPos function.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.WS_VSCROLL">
            <summary>The window has a vertical scroll bar.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_ABSALIGN">
            <summary>Indicates that the coordinates of the dialog box are screen coordinates. If this style is not specified, the coordinates are client coordinates.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_SYSMODAL">
            <summary>
            This style is obsolete and is included for compatibility with 16-bit versions of Windows.
            If you specify this style, the system creates the dialog box with the WS_EX_TOPMOST style.
            This style does not prevent the user from accessing other windows on the desktop.
            </summary>
            <remarks>Do not combine this style with the DS_CONTROL style.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_LOCALEDIT">
            <summary>
            Applies to 16-bit applications only.
            This style directs edit controls in the dialog box to allocate memory from the application's data segment.
            Otherwise, edit controls allocate storage from a global memory object.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_SETFONT">
            <summary>
            Indicates that the header of the dialog box template (either standard or extended) contains additional data specifying the font to use for text in the client area and controls of the dialog box.
            If possible, the system selects a font according to the specified font data.
            The system passes a handle to the font to the dialog box and to each control by sending them the WM_SETFONT message.
            For descriptions of the format of this font data, see DLGTEMPLATE and DLGTEMPLATEEX.
            </summary>
            <remarks>If neither DS_SETFONT nor DS_SHELLFONT is specified, the dialog box template does not include the font data.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_MODALFRAME">
            <summary>Creates a dialog box with a modal dialog-box frame that can be combined with a title bar and window menu by specifying the WS_CAPTION and WS_SYSMENU styles.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_NOIDLEMSG">
            <summary>Suppresses WM_ENTERIDLE messages that the system would otherwise send to the owner of the dialog box while the dialog box is displayed.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_SETFOREGROUND">
            <summary>
            Causes the system to use the SetForegroundWindow function to bring the dialog box to the foreground.
            This style is useful for modal dialog boxes that require immediate attention from the user regardless of whether the owner window is the foreground window.
            </summary>
            <remarks>
            The system restricts which processes can set the foreground window.
            For more information, see Foreground and Background Windows.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_3DLOOK">
            <summary>Obsolete. The system automatically applies the three-dimensional look to dialog boxes created by applications.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_FIXEDSYS">
            <summary>
            Causes the dialog box to use the SYSTEM_FIXED_FONT instead of the default SYSTEM_FONT.
            This is a monospace font compatible with the System font in 16-bit versions of Windows earlier than 3.0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_NOFAILCREATE">
            <summary>Creates the dialog box even if errors occur — for example, if a child window cannot be created or if the system cannot create a special data segment for an edit control.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_CONTROL">
            <summary>
            Creates a dialog box that works well as a child window of another dialog box, much like a page in a property sheet.
            This style allows the user to tab among the control windows of a child dialog box, use its accelerator keys, and so on.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_CENTER">
            <summary>
            Centers the dialog box in the working area of the monitor that contains the owner window.
            If no owner window is specified, the dialog box is centered in the working area of a monitor determined by the system.
            The working area is the area not obscured by the taskbar or any appbars.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_CENTERMOUSE">
            <summary>Centers the dialog box on the mouse cursor.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_CONTEXTHELP">
            <summary>
            Includes a question mark in the title bar of the dialog box.
            When the user clicks the question mark, the cursor changes to a question mark with a pointer.
            If the user then clicks a control in the dialog box, the control receives a WM_HELP message.
            The control should pass the message to the dialog box procedure, which should call the function using the HELP_WM_HELP command.
            The help application displays a pop-up window that typically contains help for the control.
            </summary>
            <remarks>
            Note that DS_CONTEXTHELP is only a placeholder.
            When the dialog box is created, the system checks for DS_CONTEXTHELP and, if it is there, adds WS_EX_CONTEXTHELP to the extended style of the dialog box.
            WS_EX_CONTEXTHELP cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_SHELLFONT">
            <summary>
            Indicates that the dialog box should use the system font.
            The typeface member of the extended dialog box template must be set to MS Shell Dlg. Otherwise, this style has no effect.
            It is also recommended that you use the DIALOGEX Resource, rather than the DIALOG Resource.
            For more information, see Dialog Box Fonts.
            </summary>
            <remarks>
            The system selects a font using the font data specified in the pointsize, weight, and italic members.
            The system passes a handle to the font to the dialog box and to each control by sending them the WM_SETFONT message.
            For descriptions of the format of this font data, see DLGTEMPLATEEX.
            If neither DS_SHELLFONT nor DS_SETFONT is specified, the extended dialog box template does not include the font data.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS.DS_USEPIXELS">
            <summary>Specifies use of pixels, not dialog coordinates.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.WS_EX">
            <summary>The following are the extended window styles.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.ACCEPTFILES">
            <summary>The window accepts drag-drop files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.APPWINDOW">
            <summary>Forces a top-level window onto the taskbar when the window is visible.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.CLIENTEDGE">
            <summary>The window has a border with a sunken edge.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.COMPOSITED">
            <summary>
            Paints all descendants of a window in bottom-to-top painting order using double-buffering. For more information, see Remarks.
            This cannot be used if the window has a class style of either CS_OWNDC or CS_CLASSDC.
            </summary>
            <remarks>Windows 2000:  This style is not supported.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.CONTEXTHELP">
            <summary>
            The title bar of the window includes a question mark.
            When the user clicks the question mark, the cursor changes to a question mark with a pointer.
            If the user then clicks a child window, the child receives a WM_HELP message.
            The child window should pass the message to the parent window procedure, which should call the WinHelp function using the HELP_WM_HELP command.
            The Help application displays a pop-up window that typically contains help for the child window.
            </summary>
            <remarks>WS_EX_CONTEXTHELP cannot be used with the WS_MAXIMIZEBOX or WS_MINIMIZEBOX styles.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.CONTROLPARENT">
            <summary>
            The window itself contains child windows that should take part in dialog box navigation.
            If this style is specified, the dialog manager recurses into children of this window when performing navigation operations such as handling the TAB key, an arrow key, or a keyboard mnemonic.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.DLGMODALFRAME">
            <summary>The window has a double border; the window can, optionally, be created with a title bar by specifying the WS_CAPTION style in the dwStyle parameter.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.LAYERED">
            <summary>The window is a layered window. This style cannot be used if the window has a class style of either CS_OWNDC or CS_CLASSDC.</summary>
            <remarks>Windows 8:  The WS_EX_LAYERED style is supported for top-level windows and child windows. Previous Windows versions support WS_EX_LAYERED only for top-level windows.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.LAYOUTRTL">
            <summary>If the shell language is Hebrew, Arabic, or another language that supports reading order alignment, the horizontal origin of the window is on the right edge. Increasing horizontal values advance to the left.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.LEFT">
            <summary>The window has generic left-aligned properties. This is the default.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.LEFTSCROLLBAR">
            <summary>If the shell language is Hebrew, Arabic, or another language that supports reading order alignment, the vertical scroll bar (if present) is to the left of the client area.</summary>
            <remarks>For other languages, the style is ignored.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.LTRREADING">
            <summary>The window text is displayed using left-to-right reading-order properties. This is the default.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.MDICHILD">
            <summary>The window is a MDI child window.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.NOACTIVATE">
            <summary>
            A top-level window created with this style does not become the foreground window when the user clicks it.
            The system does not bring this window to the foreground when the user minimizes or closes the foreground window.
            To activate the window, use the SetActiveWindow or SetForegroundWindow function.
            </summary>
            <remarks>The window does not appear on the taskbar by default. To force the window to appear on the taskbar, use the WS_EX_APPWINDOW style.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.NOINHERITLAYOUT">
            <summary>The window does not pass its window layout to its child windows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.NOPARENTNOTIFY">
            <summary>The child window created with this style does not send the WM_PARENTNOTIFY message to its parent window when it is created or destroyed.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.OVERLAPPEDWINDOW">
            <summary>The window is an overlapped window.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.PALETTEWINDOW">
            <summary>The window is palette window, which is a modeless dialog box that presents an array of commands.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.RIGHT">
            <summary>
            The window has generic "right-aligned" properties. This depends on the window class.
            This style has an effect only if the shell language is Hebrew, Arabic, or another language that supports reading-order alignment; otherwise, the style is ignored.
            </summary>
            <remarks>
            Using the WS_EX_RIGHT style for static or edit controls has the same effect as using the SS_RIGHT or ES_RIGHT style, respectively.
            Using this style with button controls has the same effect as using BS_RIGHT and BS_RIGHTBUTTON styles.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.RIGHTSCROLLBAR">
            <summary>The vertical scroll bar (if present) is to the right of the client area. This is the default.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.RTLREADING">
            <summary>
            If the shell language is Hebrew, Arabic, or another language that supports reading-order alignment, the window text is displayed using right-to-left reading-order properties.
            For other languages, the style is ignored.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.STATICEDGE">
            <summary>The window has a three-dimensional border style intended to be used for items that do not accept user input.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.TOOLWINDOW">
            <summary>
            The window is intended to be used as a floating toolbar.
            A tool window has a title bar that is shorter than a normal title bar, and the window title is drawn using a smaller font.
            A tool window does not appear in the taskbar or in the dialog that appears when the user presses ALT+TAB.
            If a tool window has a system menu, its icon is not displayed on the title bar. However, you can display the system menu by right-clicking or by typing ALT+SPACE.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.TOPMOST">
            <summary>The window should be placed above all non-topmost windows and should stay above them, even when the window is deactivated.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.TRANSPARENT">
            <summary>
            The window should not be painted until siblings beneath the window (that were created by the same thread) have been painted.
            The window appears transparent because the bits of underlying sibling windows have already been painted.
            </summary>
            <remarks>To achieve transparency without these restrictions, use the SetWindowRgn function.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.WS_EX.WINDOWEDGE">
            <summary>The window has a border with a raised edge.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MENUHEADER">
            <summary>Contains version information for the menu resource. The structure definition provided here is for explanation only; it is not present in any standard header file.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms648018%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUHEADER.wVersion">
            <summary>The version number of the menu template.</summary>
            <remarks>This member must be equal to zero to indicate that this is an RT_MENU created with a standard menu template.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUHEADER.cbHeaderSize">
            <summary>The size of the menu template header.</summary>
            <remarks>This value is zero for menus you create with a standard menu template.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUHEADER.IsOldFormat">
            <summary>Старый формат меню</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUHEADER.IsNewFormat">
            <summary>Новый формат меню</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MENUITEM">
            <summary>Contains information about each item in a menu resource that does not open a menu or a submenu.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms648024%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEM.mtOption">
            <summary>The type of menu item.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEM.IsPopUp">
            <summary>
            The structure defines a item that opens a drop-down menu or submenu.
            Subsequent structures define menu items in the corresponding drop-down menu or submenu.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEM.IsFinal">
            <summary>The structure defines the last menu item in the menu bar, drop-down menu, submenu, or shortcut menu.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MENUITEMPOPUP">
            <summary>Defines a menu item in a menu template.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMPOPUP.mtOption">
            <summary>The type of menu item.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMPOPUP.mtID">
            <summary>Menu item ID</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEMPOPUP.IsPopUp">
            <summary>
            The structure defines a item that opens a drop-down menu or submenu.
            Subsequent structures define menu items in the corresponding drop-down menu or submenu.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEMPOPUP.IsFinal">
            <summary>The structure defines the last menu item in the menu bar, drop-down menu, submenu, or shortcut menu.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX">
            <summary>Contains information about each item in a menu resource that does not open a menu or a submenu.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.dwType">
            <summary>The menu item type.</summary>
            <remarks>This member can be a combination of the type (beginning with MFT) values listed with the MENUITEMINFO structure.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.dwState">
            <summary>The menu item state.</summary>
            <remarks>This member can be a combination of the state (beginning with MFS) values listed with the MENUITEMINFO structure.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.menuId">
            <summary>
            The menu item identifier.
            This is an application-defined value that identifies the menu item.
            In an extended menu resource, items that open drop-down menus or submenus as well as command items can have identifiers.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.bResInfo">
            <summary>
            Specifies whether the menu item is the last item in the menu bar, drop-down menu, submenu, or shortcut menu and whether it is an item that opens a drop-down menu or submenu.
            This member can be zero or more of these values.
            </summary>
            <remarks>For 32-bit applications, this member is a word; for 16-bit applications, it is a byte.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.IsPopUp">
            <summary>
            The structure defines a item that opens a drop-down menu or submenu.
            Subsequent structures define menu items in the corresponding drop-down menu or submenu.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MENUITEMEX.IsFinal">
            <summary>The structure defines the last menu item in the menu bar, drop-down menu, submenu, or shortcut menu.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MFe">
            <summary>Menu item type in PE file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFe.POPUP">
            <summary>
            The structure defines a item that opens a drop-down menu or submenu.
            Subsequent structures define menu items in the corresponding drop-down menu or submenu.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFe.END">
            <summary>The structure defines the last menu item in the menu bar, drop-down menu, submenu, or shortcut menu.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MF">
            <summary>Describes the menu item.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.GRAYED">
            <summary>Indicates that the menu item is initially inactive and drawn with a gray effect.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.CHECKED">
            <summary>Indicates that the menu item has a check mark next to it.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.POPUP">
            <summary>The menu item opens a menu or a submenu; the flag is used internally by the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.MENUBARBREAK">
            <summary>
            Indicates that the menu item is placed in a new column.
            The old and new columns are separated by a bar.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.MENUBREAK">
            <summary>Indicates that the menu item is placed in a new column.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.END">
            <summary>The menu item is the last on the menu; the flag is used internally by the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.OWNERDRAW">
            <summary>
            Indicates that the owner window of the menu is responsible for drawing all visual aspects of the menu item, including highlighted, selected, and inactive states.
            This option is not valid for an item in a menu bar.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MF.HELP">
            <summary>Indicates that the menu item has a vertical separator to its left.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MFS">
            <summary>The menu item state.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms647578%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFS.CHECKED">
            <summary>Checks the menu item.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFS.DEFAULT">
            <summary>Specifies that the menu item is the default.</summary>
            <remarks>A menu can contain only one default menu item, which is displayed in bold.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFS.DISABLED">
            <summary>Disables the menu item and grays it so that it cannot be selected.</summary>
            <remarks>This is equivalent to MFS_GRAYED.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFS.ENABLED">
            <summary>Enables the menu item so that it can be selected. This is the default state.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFS.HILITE">
            <summary>Highlights the menu item.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MFT">
            <summary>Menu item types.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.STRING">
            <summary>
            Displays the menu item using a text string.
            The dwTypeData member is the pointer to a null-terminated string, and the cch member is the length of the string.</summary>
            <remarks>MFT_STRING is replaced by MIIM_STRING.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.BITMAP">
            <summary>
            Displays the menu item using a bitmap.
            The low-order word of the dwTypeData member is the bitmap handle, and the cch member is ignored.
            </summary>
            <remarks>MFT_BITMAP is replaced by MIIM_BITMAP and hbmpItem. </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.MENUBARBREAK">
            <summary>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu).
            For a drop-down menu, submenu, or shortcut menu, a vertical line separates the new column from the old.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.MENUBREAK">
            <summary>
            Places the menu item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu).
            For a drop-down menu, submenu, or shortcut menu, the columns are not separated by a vertical line.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.OWNERDRAW">
            <summary>
            Assigns responsibility for drawing the menu item to the window that owns the menu.
            The window receives a WM_MEASUREITEM message before the menu is displayed for the first time, and a WM_DRAWITEM message whenever the appearance of the menu item must be updated.
            If this value is specified, the dwTypeData member contains an application-defined value.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.RADIOCHECK">
            <summary>Displays selected menu items using a radio-button mark instead of a check mark if the hbmpChecked member is NULL.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.SEPARATOR">
            <summary>
            Specifies that the menu item is a separator.
            A menu item separator appears as a horizontal dividing line.
            The dwTypeData and cch members are ignored.
            </summary>
            <remarks>This value is valid only in a drop-down menu, submenu, or shortcut menu.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.RIGHTORDER">
            <summary>
            Specifies that menus cascade right-to-left (the default is left-to-right).
            This is used to support right-to-left languages, such as Arabic and Hebrew.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MFT.RIGHTJUSTIFY">
            <summary>
            Right-justifies the menu item and any subsequent items.
            This value is valid only if the menu item is in a menu bar.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER">
            <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/dd183376.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biSize">
            <summary>The number of bytes required by the structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biWidth">
            <summary>
            The width of the bitmap, in pixels.</summary>
            <remarks>If biCompression is BI_JPEG or BI_PNG, the biWidth member specifies the width of the decompressed JPEG or PNG image file, respectively.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biHeight">
            <summary>
            The height of the bitmap, in pixels.
            If biHeight is positive, the bitmap is a bottom-up DIB and its origin is the lower-left corner. If biHeight is negative, the bitmap is a top-down DIB and its origin is the upper-left corner.
            </summary>
            <remarks>
            If biHeight is negative, indicating a top-down DIB, biCompression must be either BI_RGB or BI_BITFIELDS. Top-down DIBs cannot be compressed.
            If biCompression is BI_JPEG or BI_PNG, the biHeight member specifies the height of the decompressed JPEG or PNG image file, respectively.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biPlanes">
            <summary>The number of planes for the target device. This value must be set to 1.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biBitCount">
            <summary>The number of bits-per-pixel. The biBitCount member of the BITMAPINFOHEADER structure determines the number of bits that define each pixel and the maximum number of colors in the bitmap.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biCompression">
            <summary>The type of compression for a compressed bottom-up bitmap (top-down DIBs cannot be compressed).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biSizeImage">
            <summary>The size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps.</summary>
            <remarks>If biCompression is BI_JPEG or BI_PNG, biSizeImage indicates the size of the JPEG or PNG image buffer, respectively.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biXPelsPerMeter">
            <summary>
            The horizontal resolution, in pixels-per-meter, of the target device for the bitmap.
            An application can use this value to select a bitmap from a resource group that best matches the characteristics of the current device.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biYPelsPerMeter">
            <summary>The vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biClrUsed">
            <summary>
            The number of color indexes in the color table that are actually used by the bitmap.
            If this value is zero, the bitmap uses the maximum number of colors corresponding to the value of the biBitCount member for the compression mode specified by biCompression.
            </summary>
            <remarks>
            If biClrUsed is nonzero and the biBitCount member is less than 16, the biClrUsed member specifies the actual number of colors the graphics engine or device driver accesses.
            If biBitCount is 16 or greater, the biClrUsed member specifies the size of the color table used to optimize performance of the system color palettes.
            If biBitCount equals 16 or 32, the optimal color palette starts immediately following the three DWORD masks.
            
            When the bitmap array immediately follows the BITMAPINFO structure, it is a packed bitmap.
            Packed bitmaps are referenced by a single pointer.
            Packed bitmaps require that the biClrUsed member must be either zero or the actual size of the color table.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.biClrImportant">
            <summary>The number of color indexes that are required for displaying the bitmap.</summary>
            <remarks>If this value is zero, all colors are required.</remarks>
        </member>
        <member name="M:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.GetDibRowWidth(System.Int32)">
            <summary>
            Returns the width of a row in a DIB Bitmap given the number of bits.
            DIB Bitmap rows always align on a DWORD boundary.
            </summary>
            <param name="width">Number of bits.</param>
            <returns>Width of a row in bytes.</returns>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.ColorsCount">
            <summary>Number of colors in palette.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.XorImageSize">
            <summary>Xor Image Size</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.BITMAPINFOHEADER.MaskImageSize">
            <summary>Size of the image mask.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.BI">
            <summary>Bitmap info type.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.RGB">
            <summary>An uncompressed format.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.RLE8">
            <summary>A run-length encoded (RLE) format for bitmaps with 8 bpp. The compression format is a 2-byte format consisting of a count byte followed by a byte containing a color index.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.RLE4">
            <summary>An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format consisting of a count byte followed by two word-length color indexes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.BITFIELDS">
            <summary>Specifies that the bitmap is not compressed and that the color table consists of three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel.</summary>
            <remarks>This is valid when used with 16- and 32-bpp bitmaps.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.JPEG">
            <summary>Indicates that the image is a JPEG image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.BI.PNG">
            <summary>Indicates that the image is a PNG image.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO">
            <summary>Represents the organization of data in a file-version resource. It is the root structure that contains all other file-version information structures.</summary>
            <remarks>
            This structure is not a true C-language structure because it contains variable-length members.
            This structure was created solely to depict the organization of data in a version resource and does not appear in any of the header files shipped with the Windows Software Development Kit (SDK).
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO.wLength">
            <summary>The length, in bytes, of the VS_VERSIONINFO structure. This length does not include any padding that aligns any subsequent version resource data on a 32-bit boundary.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO.wValueLength">
            <summary>The length, in bytes, of the Value member. This value is zero if there is no Value member associated with the current version structure. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO.wType">
            <summary>The type of data in the version resource. This member is 1 if the version resource contains text data and 0 if the version resource contains binary data. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO.szKey">
            <summary>The Unicode string L"VS_VERSION_INFO". </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_VERSIONINFO.Padding1">
            <summary>Contains as many zero words as necessary to align the Value member on a 32-bit boundary. </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VersionDataType">
            <summary>Типы данных в версии</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VersionDataType.Binary">
            <summary>Бинарные данных</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VersionDataType.Text">
            <summary>Текстовые данных</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO">
            <summary>Contains version information for a file. This information is language and code page independent.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwSignature">
            <summary>Contains the value 0xFEEF04BD. This is used with the szKey member of the VS_VERSIONINFO structure when searching a file for the VS_FIXEDFILEINFO structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwStructVersion">
            <summary>The binary version number of this structure. The high-order word of this member contains the major version number, and the low-order word contains the minor version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileVersionMS">
            <summary>The most significant 32 bits of the file's binary version number. This member is used with dwFileVersionLS to form a 64-bit value used for numeric comparisons.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileVersionLS">
            <summary>The least significant 32 bits of the file's binary version number. This member is used with dwFileVersionMS to form a 64-bit value used for numeric comparisons.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwProductVersionMS">
            <summary>The most significant 32 bits of the binary version number of the product with which this file was distributed. This member is used with dwProductVersionLS to form a 64-bit value used for numeric comparisons.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwProductVersionLS">
            <summary>The least significant 32 bits of the binary version number of the product with which this file was distributed. This member is used with dwProductVersionMS to form a 64-bit value used for numeric comparisons.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileFlagMask">
            <summary>Contains a bitmask that specifies the valid bits in dwFileFlags. A bit is valid only if it was defined when the file was created.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileFlags">
            <summary>Contains a bitmask that specifies the Boolean attributes of the file. This member can include one or more of the following values. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileOS">
            <summary>The operating system for which this file was designed. This member can be one of the following values.</summary>
            <remarks>An application can combine these values to indicate that the file was designed for one operating system running on another. The following dwFileOS values are examples of this, but are not a complete list.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileType">
            <summary>The general type of file. This member can be one of the following values. All other values are reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileSubtype">
            <summary>The function of the file. The possible values depend on the value of dwFileType. For all values of dwFileType not described in the following list, dwFileSubtype is zero.</summary>
            <remarks>If dwFileType is VFT_DRV, dwFileSubtype can be one of the following values.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileDateMS">
            <summary>The most significant 32 bits of the file's 64-bit binary creation date and time stamp.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.dwFileDateLS">
            <summary>The least significant 32 bits of the file's 64-bit binary creation date and time stamp.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.IsValid">
            <summary>Structure is valid</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.FileVersion">
            <summary>File version number</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.VS_FIXEDFILEINFO.ProductVersion">
            <summary>Product version number</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VS_FF">
            <summary>Contains a bitmask that specifies the Boolean attributes of the file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.DEBUG">
            <summary>The file contains debugging information or is compiled with debugging features enabled.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.INFOINFERRED">
            <summary>The file's version structure was created dynamically; therefore, some of the members in this structure may be empty or incorrect. This flag should never be set in a file's VS_VERSIONINFO data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.PATCHED">
            <summary>The file has been modified and is not identical to the original shipping file of the same version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.PRERELEASE">
            <summary>The file is a development version, not a commercially released product.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.PRIVATEBUILD">
            <summary>The file was not built using standard release procedures. If this flag is set, the StringFileInfo structure should contain a PrivateBuild entry.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VS_FF.SPECIALBUILD">
            <summary>The file was built by the original company using standard release procedures but is a variation of the normal file of the same version number. If this flag is set, the StringFileInfo structure should contain a SpecialBuild entry.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VOS">
            <summary>The operating system for which this file was designed.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.DOS">
            <summary>The file was designed for MS-DOS.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.NT">
            <summary>The file was designed for Windows NT.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.WINDOWS16">
            <summary>The file was designed for 16-bit Windows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.WINDOWS32">
            <summary>The file was designed for 32-bit Windows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.OS216">
            <summary>The file was designed for 16-bit OS/2.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.OS232">
            <summary>The file was designed for 32-bit OS/2.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.PM16">
            <summary>The file was designed for 16-bit Presentation Manager.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.PM32">
            <summary>The file was designed for 32-bit Presentation Manager.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.UNKNOWN">
            <summary>The operating system for which the file was designed is unknown to the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.DOS_WINDOWS16">
            <summary>The file was designed for 16-bit Windows running on MS-DOS.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.DOS_WINDOWS32">
            <summary>The file was designed for 32-bit Windows running on MS-DOS.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.NT_WINDOWS32">
            <summary>The file was designed for Windows NT.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.OS216_PM16">
            <summary>The file was designed for 16-bit Presentation Manager running on 16-bit OS/2.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VOS.OS232_PM32">
            <summary>The file was designed for 32-bit Presentation Manager running on 32-bit OS/2.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VFT">
            <summary>The general type of file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.APP">
            <summary>The file contains an application.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.DLL">
            <summary>The file contains a DLL.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.DRV">
            <summary>The file contains a device driver. If dwFileType is VFT_DRV, dwFileSubtype contains a more specific description of the driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.FONT">
            <summary>The file contains a font. If dwFileType is VFT_FONT, dwFileSubtype contains a more specific description of the font file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.STATIC_LIB">
            <summary>The file contains a static-link library.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.UNKNOWN">
            <summary>The file type is unknown to the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT.VXD">
            <summary>The file contains a virtual device.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VFT2">
            <summary>The function of the file. If dwFileType is VFT_DRV, dwFileSubtype can be one of the following values.</summary>
            <remarks>The possible values depend on the value of dwFileType. For all values of dwFileType not described in the following list, dwFileSubtype is zero.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_COMM">
            <summary>The file contains a communications driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_DISPLAY">
            <summary>The file contains a display driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_INSTALLABLE">
            <summary>The file contains an installable driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_KEYBOARD">
            <summary>The file contains a keyboard driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_LANGUAGE">
            <summary>The file contains a language driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_MOUSE">
            <summary>The file contains a mouse driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_NETWORK">
            <summary>The file contains a network driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_PRINTER">
            <summary>The file contains a printer driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_SOUND">
            <summary>The file contains a sound driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_SYSTEM">
            <summary>The file contains a system driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.DRV_VERSIONED_PRINTER">
            <summary>The file contains a versioned printer driver.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VFT2.UNKNOWN">
            <summary>The driver type is unknown by the system.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.VarFileInfo">
            <summary>Represents the organization of data in a file-version resource. It contains version information that can be displayed for a particular language and code page.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VarFileInfo.wLength">
            <summary>The length, in bytes, of the entire StringFileInfo block, including all structures indicated by the Children member. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VarFileInfo.wValueLength">
            <summary>This member is always equal to zero. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.VarFileInfo.wType">
            <summary>The type of data in the version resource. This member is 1 if the version resource contains text data and 0 if the version resource contains binary data. </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.VarFileInfo.ValueLength">
            <summary>Size of next value</summary>
            <exception cref="T:NotImplementedException">Only Text data type supported</exception>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.StringTable">
            <summary>Represents the organization of data in a file-version resource. It contains version information that can be displayed for a particular language and code page.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.StringTable.wLength">
            <summary>The length, in bytes, of this StringTable structure, including all structures indicated by the Children member.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.StringTable.wValueLength">
            <summary>This member is always equal to zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.StringTable.wType">
            <summary>The type of data in the version resource. This member is 1 if the version resource contains text data and 0 if the version resource contains binary data. </summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.V_STRING">
            <summary>
            Represents the organization of data in a file-version resource.
            It contains a string that describes a specific aspect of a file, for example, a file's version, its copyright notices, or its trademarks.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.V_STRING.wLength">
            <summary>The length, in bytes, of this String structure. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.V_STRING.wValueLength">
            <summary>The size, in words, of the Value member. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.V_STRING.wType">
            <summary>
            The type of data in the version resource.
            This member is 1 if the version resource contains text data and 0 if the version resource contains binary data.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.V_STRING.ValueLength">
            <summary>Length of the value</summary>
            <exception cref="T:NotImplementedException">Only Text data type supported</exception>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY">
            <summary>Contains information about an individual font in a font resource group.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms648014%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfVersion">
            <summary>A user-defined version number for the resource data that tools can use to read and write resource files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfSize">
            <summary>The size of the file, in bytes. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfCopyright">
            <summary>The font supplier's copyright information.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfType">
            <summary>The type of font file. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfPoints">
            <summary>The point size at which this character set looks best.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfVertRes">
            <summary>The vertical resolution, in dots per inch, at which this character set was digitized.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfHorizRes">
            <summary>The horizontal resolution, in dots per inch, at which this character set was digitized.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfAscent">
            <summary>The distance from the top of a character definition cell to the baseline of the typographical font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfInternalLeading">
            <summary>
            The amount of leading inside the bounds set by the dfPixHeight member.
            Accent marks and other diacritical characters can occur in this area.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfExternalLeading">
            <summary>The amount of extra leading that the application adds between rows.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfItalic">
            <summary>An italic font if not equal to zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfUnderline">
            <summary>An underlined font if not equal to zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfStrikeOut">
            <summary>A strikeout font if not equal to zero. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfWeight">
            <summary>The weight of the font in the range 0 through 1000. For example, 400 is roman and 700 is bold. If this value is zero, a default weight is used.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfCharSet">
            <summary>The character set of the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfPixWidth">
            <summary>
            The width of the grid on which a vector font was digitized.
            For raster fonts, if the member is not equal to zero, it represents the width for all the characters in the bitmap. If the member is equal to zero, the font has variable-width characters.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfPixHeight">
            <summary>The height of the character bitmap for raster fonts or the height of the grid on which a vector font was digitized.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfPitchAndFamily">
            <summary>The pitch and the family of the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfAvgWidth">
            <summary>
            The average width of characters in the font (generally defined as the width of the letter x).
            This value does not include the overhang required for bold or italic characters.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfMaxWidth">
            <summary>The width of the widest character in the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfFirstChar">
            <summary>The first character code defined in the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfLastChar">
            <summary>The last character code defined in the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfDefaultChar">
            <summary>The character to substitute for characters not in the font.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfBreakChar">
            <summary>The character that will be used to define word breaks for text justification.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfWidthBytes">
            <summary>
            The number of bytes in each row of the bitmap.
            This value is always even so that the rows start on word boundaries.
            For vector fonts, this member has no meaning.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfDevice">
            <summary>
            The offset in the file to a null-terminated string that specifies a device name.
            For a generic font, this value is zero.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfFace">
            <summary>The offset in the file to a null-terminated string that names the typeface.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.dfReserved">
            <summary>This member is reserved.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.IsItalic">
            <summary>The font is italic</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.IsUnderline">
            <summary>The font is underline</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.FONTDIRENTRY.IsStrikeOut">
            <summary>The font is strikeout</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.FW">
            <summary>Font weight</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.DONTCARE">
            <summary>Ignore</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.THIN">
            <summary>Thin</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.EXTRALIGHT">
            <summary>Extra light</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.LIGHT">
            <summary>Light</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.NORMAL">
            <summary>Normal</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.MEDIUM">
            <summary>Medium</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.SEMIBOLD">
            <summary>Semi bold</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.BOLD">
            <summary>Bold</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.EXTRABOLD">
            <summary>Extra bold</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.FW.HEAVY">
            <summary>Heawy</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.CHARSET">
            <summary>The character set</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.ANSI">
            <summary>ANSI charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.DEFAULT">
            <summary>
            DEFAULT_CHARSET is set to a value based on the current system locale.
            For example, when the system locale is English (United States), it is set as ANSI_CHARSET.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.SYMBOL">
            <summary>Symbol charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.MAC">
            <summary>Mac charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.SHIFTJIS">
            <summary>Shiftjis charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.HANGEUL">
            <summary>Hangeul charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.JOHAB">
            <summary>Johab charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.GB2312">
            <summary>Gb2312 charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.CHINESEBIG5">
            <summary>Chinesebig5 charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.GREEK">
            <summary>Greek charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.TURKISH">
            <summary>Turkish charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.VIETNAMESE">
            <summary>Vietnamese charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.HEBREW">
            <summary>Hebrew charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.ARABIC">
            <summary>Arabic charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.BALTIC">
            <summary>Baltic charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.THAI">
            <summary>Thai charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.EASTEUROPE">
            <summary>Easteurope charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.RUSSIAN">
            <summary>Russian charset</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.CHARSET.OEM">
            <summary>The OEM_CHARSET value specifies a character set that is operating-system dependent.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK">
            <summary>Contains information about message strings with identifiers in the range indicated by the LowId and HighId members.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK.LowId">
            <summary>The lowest message identifier contained within this structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK.HighId">
            <summary>The highest message identifier contained within this structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK.OffsetToEntries">
            <summary>
            The offset, in bytes, from the beginning of the MESSAGE_RESOURCE_DATA structure to the MESSAGE_RESOURCE_ENTRY structures in this MESSAGE_RESOURCE_BLOCK.
            The MESSAGE_RESOURCE_ENTRY structures contain the message strings.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_ENTRY">
            <summary>Contains the error message or message box display text for a message table resource. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_ENTRY.Length">
            <summary>The length, in bytes, of the MESSAGE_RESOURCE_ENTRY structure. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_ENTRY.Flags">
            <summary>
            Indicates that the string is encoded in Unicode, if equal to the value 0x0001.
            Indicates that the string is encoded in ANSI, if equal to the value 0x0000.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_ENTRY.MessageLength">
            <summary>Pointer to an array that contains the error message or message box display text.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Resource.ResourceEncodingType">
            <summary>Type of resource encoding</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ResourceEncodingType.Ansi">
            <summary>ANSI encoding</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Resource.ResourceEncodingType.Unicode">
            <summary>Unicode encoding</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER">
            <summary>COM+ 2.0 header structure.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.cb">
            <summary>Size of the header in bytes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.MajorRuntimeVersion">
            <summary>The minimum version of the runtime required to run this program. For the first release of .NET, this value is 1.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.MinorRuntimeVersion">
            <summary>The minor portion of the version. Currently 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.MetaData">
            <summary>
            The RVA to the metadata tables.
            Symbol table and startup information.</summary>
            <remarks>Pointer to <see cref="T:IMAGE_COR20_METADATA"/> section.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.Flags">
            <summary>Flag values containing attributes for this image.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.EntryPointToken">
            <summary>Token for the MethodDef of the entry point for the image. The .NET runtime calls this method to begin managed execution in the file.</summary>
            <remarks>
            If COMIMAGE_FLAGS.NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
            If COMIMAGE_FLAGS.NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.DataDirectory">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.Item(AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY)">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_COR20_HEADER.RuntimeVersion">
            <summary>Version of the runtime required to run this program.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR">
            <summary>Import directory header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.Characteristics">
            <summary>
            At one time, this may have been a set of flags.
            However, Microsoft changed its meaning and never bothered to update WINNT.H. This field is really an offset (an RVA) to an array of pointers. Each of these pointers points to an <see cref="T:IMAGE_IMPORT_BY_NAME"/> structure.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp">
            <summary>The time/date stamp indicating when the file was built.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.ForwarderChain">
            <summary>
            This field relates to forwarding.
            Forwarding involves one DLL sending on references to one of its functions to another DLL.
            For example, in Windows NT, NTDLL.DLL appears to forward some of its exported functions to KERNEL32.DLL.
            An application may think it's calling a function in NTDLL.DLL, but it actually ends up calling into KERNEL32.DLL.
            This field contains an index into FirstThunk array (described momentarily).
            The function indexed by this field will be forwarded to another DLL.
            Unfortunately, the format of how a function is forwarded isn't documented, and examples of forwarded functions are hard to find.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.Name">
            <summary>This is an RVA to a NULL-terminated ASCII string containing the imported DLL's name. Common examples are "KERNEL32.DLL" and "USER32.DLL".</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.FirstThunk">
            <summary>
            This field is an offset (an RVA) to an IMAGE_THUNK_DATA union.
            In almost every case, the union is interpreted as a pointer to an <see cref="T:IMAGE_IMPORT_BY_NAME"/> structure.
            If the field isn't one of these pointers, then it's supposedly treated as an export ordinal value for the DLL that's being imported.
            It's not clear from the documentation if you really can import a function by ordinal rather than by name. 
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.TimeDate">
            <summary>The time/date stamp indicating when the file was built.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR.IsEmpty">
            <summary>Structure is empty</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA32">
            <summary>Imported function from the image</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA32.ForwarderString">
            <summary>RVA to a forwarder string.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA32.Function">
            <summary>Memory address of the imported function.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA32.Ordinal">
            <summary>Ordinal value of imported API.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA32.AddressOfData">
            <summary>RVA to an <see cref="T:IMAGE_IMPORT_BY_NAME"/> with the imported API name.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA64">
            <summary>Imported function from the image</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA64.ForwarderString">
            <summary>RVA to a forwarder string.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA64.Function">
            <summary>Memory address of the imported function.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA64.Ordinal">
            <summary>Ordinal value of imported API.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_THUNK_DATA64.AddressOfData">
            <summary>RVA to an <see cref="T:IMAGE_IMPORT_BY_NAME"/> with the imported API name.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_BY_NAME">
            <summary>Import Format</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_BY_NAME.Hint">
            <summary>Ordinal index in exported module.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_BY_NAME.Name">
            <summary>ASCII string with the name of the imported function.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_IMPORT_BY_NAME.IsByOrdinal">
            <summary>Function is loaded by Ordinal index</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_RUNTIME_FUNCTION_ENTRY">
            <summary>
            Some architectures (including the IA-64) don't use frame-based exception handling, like the x86 does; instead, they used table-based exception handling in which there is a table containing information about every function that might be affected by exception unwinding.
            The data for each function includes the starting address, the ending address, and information about how and where the exception should be handled.
            When an exception occurs, the system searches through the tables to locate the appropriate entry and handles it.
            The exception table is an array of <see cref="T:IMAGE_RUNTIME_FUNCTION_ENTRY"/> structures.
            The array is pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION entry in the DataDirectory.
            </summary>
            <remarks>http://msdn.microsoft.com/en-US/library/ft9x1kdx%28v=vs.80%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_RUNTIME_FUNCTION_ENTRY.BeginAddress">
            <summary>Address of the first instruction in the function. It is the function's entry address.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_RUNTIME_FUNCTION_ENTRY.EndAddress">
            <summary>Address of the last instruction in the function. It is the function's end address.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_RUNTIME_FUNCTION_ENTRY.UnwindInfoAddress">
            <summary>
            The UnwindInfoAddress can have two different meanings.
            First, it can be a reference to another runtime function entry in .pdata.
            This is indicated, that the LSB is set to one.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_RUNTIME_FUNCTION_ENTRY.IsLatEntry">
            <summary>Этот ряд последний.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_DATA_DIRECTORY">
            <summary>Represents the data directory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DATA_DIRECTORY.VirtualAddress">
            <summary>The relative virtual address of the table.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_DATA_DIRECTORY.Size">
            <summary>The size of the table, in bytes.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_DATA_DIRECTORY.IsEmpty">
            <summary>Data directory contains information.</summary>
            <remarks>Директория проверяется по полю Size. У некоторых директорий поде Size игнорируется. См. документацию.</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32">
            <summary>Optional header format</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.Magic">
            <summary>
            A signature WORD, identifying what type of header this is.
            The two most common values are IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b and IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MajorLinkerVersion">
            <summary>
            The major version of the linker used to build this executable.
            For PE files from the Microsoft linker, this version number corresponds to the Visual Studio version number (for example, version 6 for Visual Studio 6.0).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MinorLinkerVersion">
            <summary>The minor version of the linker used to build this executable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfCode">
            <summary>The combined total size of all sections with the IMAGE_SCN_CNT_CODE attribute.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfInitializedData">
            <summary>The combined size of all initialized data sections.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfUninitializedData">
            <summary>
            The size of all sections with the uninitialized data attributes.
            This field will often be 0, since the linker can append uninitialized data to the end of regular data sections.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.AddressOfEntryPoint">
            <summary>
            The RVA of the first code byte in the file that will be executed.
            For DLLs, this entrypoint is called during process initialization and shutdown and during thread creations/destructions.
            In most executables, this address doesn't directly point to main, WinMain, or DllMain.
            Rather, it points to runtime library code that calls the aforementioned functions.
            This field can be set to 0 in DLLs, and none of the previous notifications will be received.
            The linker /NOENTRY switch sets this field to 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.BaseOfCode">
            <summary>The RVA of the first byte of code when loaded in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.BaseOfData">
            <summary>
            Theoretically, the RVA of the first byte of data when loaded into memory.
            However, the values for this field are inconsistent with different versions of the Microsoft linker.
            This field is not present in 64-bit executables.
            </summary>
            <remarks>PE32 contains this additional field</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.ImageBase">
            <summary>
            The preferred load address of this file in memory.
            The loader attempts to load the PE file at this address if possible (that is, if nothing else currently occupies that memory, it's aligned properly and at a legal address, and so on).
            If the executable loads at this address, the loader can skip the step of applying base relocations (described in Part 2 of this article).
            For EXEs, the default ImageBase is 0x400000. For DLLs, it's 0x10000000.
            The ImageBase can be set at link time with the /BASE switch, or later with the REBASE utility.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SectionAlignment">
            <summary>
            The alignment of sections when loaded into memory.
            The alignment must be greater or equal to the file alignment field (mentioned next).
            The default alignment is the page size of the target CPU.
            For user mode executables to run under Windows 9x or Windows Me, the minimum alignment size is a page (4KB).
            This field can be set with the linker /ALIGN switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.FileAlignment">
            <summary>
            The alignment of sections within the PE file.
            For x86 executables, this value is usually either 0x200 or 0x1000.
            The default has changed with different versions of the Microsoft linker.
            This value must be a power of 2, and if the SectionAlignment is less than the CPU's page size, this field must match the SectionAlignment.
            The linker switch /OPT:WIN98 sets the file alignment on x86 executables to 0x1000, while /OPT:NOWIN98 sets the alignment to 0x200.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MajorOperatingSystemVersion">
            <summary>
            The major version number of the required operating system.
            With the advent of so many versions of Windows, this field has effectively become irrelevant.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MinorOperatingSystemVersion">
            <summary>The minor version number of the required OS.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MajorImageVersion">
            <summary>
            The major version number of this file.
            Unused by the system and can be 0. It can be set with the linker /VERSION switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MinorImageVersion">
            <summary>The minor version number of this file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MajorSubsystemVersion">
            <summary>
            The major version of the operating subsystem needed for this executable.
            At one time, it was used to indicate that the newer Windows 95 or Windows NT 4.0 user interface was required, as opposed to older versions of the Windows NT interface.
            Today, because of the proliferation of the various versions of Windows, this field is effectively unused by the system and is typically set to the value 4.
            Set with the linker /SUBSYSTEM switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.MinorSubsystemVersion">
            <summary>The minor version of the operating subsystem needed for this executable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.Win32VersionValue">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfImage">
            <summary>
            SizeOfImage contains the RVA that would be assigned to the section following the last section if it existed.
            This is effectively the amount of memory that the system needs to reserve when loading this file into memory.
            This field must be a multiple of the section alignment.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfHeaders">
            <summary>
            The combined size of the MS-DOS header, PE headers, and section table.
            All of these items will occur before any code or data sections in the PE file.
            The value of this field is rounded up to a multiple of the file alignment.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.CheckSum">
            <summary>
            The checksum of the image.
            The CheckSumMappedFile API in IMAGEHLP.DLL can calculate this value.
            Checksums are required for kernel-mode drivers and some system DLLs.
            Otherwise, this field can be 0.
            The checksum is placed in the file when the /RELEASE linker switch is used.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.Subsystem">
            <summary>
            An enum value indicating what subsystem (user interface type) the executable expects. This field is only important for EXEs. Important values include:
            IMAGE_SUBSYSTEM_NATIVE       // Image doesn't require a subsystem
            IMAGE_SUBSYSTEM_WINDOWS_GUI  // Use the Windows GUI
            IMAGE_SUBSYSTEM_WINDOWS_CUI  // Run as a console mode application
            When run, the OS creates a console window for it, and provides stdin, stdout, and stderr file handles.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.DllCharacteristics">
            <summary>
            Flags indicating characteristics of this DLL. These correspond to the IMAGE_DLLCHARACTERISTICS_xxx fields #defines. Current values are:
            IMAGE_DLLCHARACTERISTICS_NO_BIND - Do not bind this image
            IMAGE_DLLCHARACTERISTICS_WDM_DRIVER - Driver uses WDM model
            IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE - When the terminal server loads an application that is not Terminal- Services-aware, it also loads a DLL that contains compatibility code.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfStackReserve">
            <summary>
            The number of bytes to reserve for the stack.
            Only the memory specified by the SizeOfStackCommit member is committed at load time; the rest is made available one page at a time until this reserve size is reached.
            </summary>
            <remarks>
            In EXE files, the maximum size the initial thread in the process can grow to.
            This is 1MB by default. Not all this memory is committed initially.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfStackCommit">
            <summary>The number of bytes to commit for the stack.</summary>
            <remarks>In EXE files, the amount of memory initially committed to the stack. By default, this field is 4KB.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfHeapReserve">
            <summary>
            The number of bytes to reserve for the local heap.
            Only the memory specified by the SizeOfHeapCommit member is committed at load time; the rest is made available one page at a time until this reserve size is reached.
            </summary>
            <remarks>
            In EXE files, the initial reserved size of the default process heap.
            This is 1MB by default.
            In current versions of Windows, however, the heap can grow beyond this size without intervention by the user.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SizeOfHeapCommit">
            <summary>The number of bytes to commit for the local heap.</summary>
            <remarks>In EXE files, the size of memory committed to the heap. By default, this is 4KB.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.LoaderFlags">
            <summary>Reserved, must be zero.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.NumberOfRvaAndSizes">
            <summary>
            The number of directory entries in the remainder of the optional header.
            Each entry describes a location and size.
            </summary>
            <remarks>
            At the end of the IMAGE_NT_HEADERS structure is an array of IMAGE_DATA_DIRECTORY structures.
            This field contains the number of entries in the array.
            This field has been 16 since the earliest releases of Windows NT.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.DataDirectory">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.Item(AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY)">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.LinkerVersion">
            <summary>Version of the linker used to build this executable</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.OperatingSystemVersion">
            <summary>Version number of the required operating system</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.ImageVersion">
            <summary>Version number of this file</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER32.SubsystemVersion">
            <summary>Version of the operating subsystem needed for this executable</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64">
            <summary>Optional header format</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.Magic">
            <summary>
            A signature WORD, identifying what type of header this is.
            The two most common values are IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b and IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MajorLinkerVersion">
            <summary>
            The major version of the linker used to build this executable.
            For PE files from the Microsoft linker, this version number corresponds to the Visual Studio version number (for example, version 6 for Visual Studio 6.0).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MinorLinkerVersion">
            <summary>The minor version of the linker used to build this executable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfCode">
            <summary>The combined total size of all sections with the IMAGE_SCN_CNT_CODE attribute.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfInitializedData">
            <summary>The combined size of all initialized data sections.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfUninitializedData">
            <summary>
            The size of all sections with the uninitialized data attributes.
            This field will often be 0, since the linker can append uninitialized data to the end of regular data sections.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.AddressOfEntryPoint">
            <summary>
            The RVA of the first code byte in the file that will be executed.
            For DLLs, this entrypoint is called during process initialization and shutdown and during thread creations/destructions.
            In most executables, this address doesn't directly point to main, WinMain, or DllMain.
            Rather, it points to runtime library code that calls the aforementioned functions.
            This field can be set to 0 in DLLs, and none of the previous notifications will be received.
            The linker /NOENTRY switch sets this field to 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.BaseOfCode">
            <summary>The RVA of the first byte of code when loaded in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.ImageBase">
            <summary>
            The preferred load address of this file in memory.
            The loader attempts to load the PE file at this address if possible (that is, if nothing else currently occupies that memory, it's aligned properly and at a legal address, and so on).
            If the executable loads at this address, the loader can skip the step of applying base relocations (described in Part 2 of this article).
            For EXEs, the default ImageBase is 0x400000. For DLLs, it's 0x10000000.
            The ImageBase can be set at link time with the /BASE switch, or later with the REBASE utility.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SectionAlignment">
            <summary>
            The alignment of sections when loaded into memory.
            The alignment must be greater or equal to the file alignment field (mentioned next).
            The default alignment is the page size of the target CPU.
            For user mode executables to run under Windows 9x or Windows Me, the minimum alignment size is a page (4KB).
            This field can be set with the linker /ALIGN switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.FileAlignment">
            <summary>
            The alignment of sections within the PE file.
            For x86 executables, this value is usually either 0x200 or 0x1000.
            The default has changed with different versions of the Microsoft linker.
            This value must be a power of 2, and if the SectionAlignment is less than the CPU's page size, this field must match the SectionAlignment.
            The linker switch /OPT:WIN98 sets the file alignment on x86 executables to 0x1000, while /OPT:NOWIN98 sets the alignment to 0x200.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MajorOperatingSystemVersion">
            <summary>
            The major version number of the required operating system.
            With the advent of so many versions of Windows, this field has effectively become irrelevant.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MinorOperatingSystemVersion">
            <summary>The minor version number of the required OS.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MajorImageVersion">
            <summary>
            The major version number of this file.
            Unused by the system and can be 0. It can be set with the linker /VERSION switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MinorImageVersion">
            <summary>The minor version number of this file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MajorSubsystemVersion">
            <summary>
            The major version of the operating subsystem needed for this executable.
            At one time, it was used to indicate that the newer Windows 95 or Windows NT 4.0 user interface was required, as opposed to older versions of the Windows NT interface.
            Today, because of the proliferation of the various versions of Windows, this field is effectively unused by the system and is typically set to the value 4.
            Set with the linker /SUBSYSTEM switch.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.MinorSubsystemVersion">
            <summary>The minor version of the operating subsystem needed for this executable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.Win32VersionValue">
            <summary>Another field that never took off. Typically set to 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfImage">
            <summary>
            SizeOfImage contains the RVA that would be assigned to the section following the last section if it existed.
            This is effectively the amount of memory that the system needs to reserve when loading this file into memory.
            This field must be a multiple of the section alignment.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfHeaders">
            <summary>
            The combined size of the MS-DOS header, PE headers, and section table.
            All of these items will occur before any code or data sections in the PE file.
            The value of this field is rounded up to a multiple of the file alignment.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.CheckSum">
            <summary>
            The checksum of the image.
            The CheckSumMappedFile API in IMAGEHLP.DLL can calculate this value.
            Checksums are required for kernel-mode drivers and some system DLLs.
            Otherwise, this field can be 0.
            The checksum is placed in the file when the /RELEASE linker switch is used.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.Subsystem">
            <summary>
            An enum value indicating what subsystem (user interface type) the executable expects. This field is only important for EXEs. Important values include:
            IMAGE_SUBSYSTEM_NATIVE       // Image doesn't require a subsystem
            IMAGE_SUBSYSTEM_WINDOWS_GUI  // Use the Windows GUI
            IMAGE_SUBSYSTEM_WINDOWS_CUI  // Run as a console mode application
            When run, the OS creates a console window for it, and provides stdin, stdout, and stderr file handles.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.DllCharacteristics">
            <summary>
            Flags indicating characteristics of this DLL. These correspond to the IMAGE_DLLCHARACTERISTICS_xxx fields #defines. Current values are:
            IMAGE_DLLCHARACTERISTICS_NO_BIND - Do not bind this image
            IMAGE_DLLCHARACTERISTICS_WDM_DRIVER - Driver uses WDM model
            IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE - When the terminal server loads an application that is not Terminal- Services-aware, it also loads a DLL that contains compatibility code.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfStackReserve">
            <summary>
            The number of bytes to reserve for the stack.
            Only the memory specified by the SizeOfStackCommit member is committed at load time; the rest is made available one page at a time until this reserve size is reached.
            </summary>
            <remarks>
            In EXE files, the maximum size the initial thread in the process can grow to.
            This is 1MB by default. Not all this memory is committed initially.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfStackCommit">
            <summary>The number of bytes to commit for the stack.</summary>
            <remarks>In EXE files, the amount of memory initially committed to the stack. By default, this field is 4KB.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfHeapReserve">
            <summary>
            The number of bytes to reserve for the local heap.
            Only the memory specified by the SizeOfHeapCommit member is committed at load time; the rest is made available one page at a time until this reserve size is reached.
            </summary>
            <remarks>
            In EXE files, the initial reserved size of the default process heap.
            This is 1MB by default.
            In current versions of Windows, however, the heap can grow beyond this size without intervention by the user.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SizeOfHeapCommit">
            <summary>The number of bytes to commit for the local heap.</summary>
            <remarks>In EXE files, the size of memory committed to the heap. By default, this is 4KB.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.LoaderFlags">
            <summary>This member is obsolete.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.NumberOfRvaAndSizes">
            <summary>
            The number of directory entries in the remainder of the optional header.
            Each entry describes a location and size.
            </summary>
            <remarks>
            At the end of the IMAGE_NT_HEADERS structure is an array of IMAGE_DATA_DIRECTORY structures.
            This field contains the number of entries in the array.
            This field has been 16 since the earliest releases of Windows NT.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.DataDirectory">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.Item(AlphaOmega.Debug.WinNT.IMAGE_DIRECTORY_ENTRY)">
            <summary>DataDirectories</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.LinkerVersion">
            <summary>Version of the linker used to build this executable</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.OperatingSystemVersion">
            <summary>Version number of the required operating system</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.ImageVersion">
            <summary>Version number of this file</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_OPTIONAL_HEADER64.SubsystemVersion">
            <summary>Version of the operating subsystem needed for this executable</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32">
            <summary>Represents the PE header format.</summary>
            <remarks>The actual structure in Winnt.h is named IMAGE_NT_HEADERS32 and IMAGE_NT_HEADERS is defined as IMAGE_NT_HEADERS32. However, if _WIN64 is defined, then IMAGE_NT_HEADERS is defined as IMAGE_NT_HEADERS64.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32.Signature">
            <summary>A 4-byte signature identifying the file as a PE image. The bytes are "PE\0\0".</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32.FileHeader">
            <summary>An IMAGE_FILE_HEADER structure that specifies the file header.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32.OptionalHeader">
            <summary>An IMAGE_OPTIONAL_HEADER structure that specifies the optional file header.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32.IsValid">
            <summary>Valid NT header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS32.SignatureStr">
            <summary>Signature as String</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64">
            <summary>Represents the PE header format.</summary>
            <remarks>The actual structure in Winnt.h is named IMAGE_NT_HEADERS32 and IMAGE_NT_HEADERS is defined as IMAGE_NT_HEADERS32. However, if _WIN64 is defined, then IMAGE_NT_HEADERS is defined as IMAGE_NT_HEADERS64.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64.Signature">
            <summary>A 4-byte signature identifying the file as a PE image. The bytes are "PE\0\0".</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64.FileHeader">
            <summary>An IMAGE_FILE_HEADER structure that specifies the file header.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64.OptionalHeader">
            <summary>An IMAGE_OPTIONAL_HEADER structure that specifies the optional file header.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64.IsValid">
            <summary>Valid NT header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_NT_HEADERS64.SignatureStr">
            <summary>Signature as String</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY">
            <summary>Export Format</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.ExportFlags">
            <summary>Reserved, must be 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.TimeDateStamp">
            <summary>The time and date that the export data was created.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.MajorVersion">
            <summary>The major version number.</summary>
            <remarks>The major and minor version numbers can be set by the user.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.MinorVersion">
            <summary>The minor version number.</summary>
            /// <remarks>The major and minor version numbers can be set by the user.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.NameRva">
            <summary>The address of the ASCII string that contains the name of the DLL. This address is relative to the image base.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.OrdinalBase">
            <summary>
            This field contains the starting ordinal value to be used for this executable's exports.
            Normally, this value is 1, but it's not required to be so.
            When looking up an export by ordinal, the value of this field is subtracted from the ordinal, with the result used as a zero-based index into the Export Address Table (EAT).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.NumberOfFunctions">
            <summary>The number of entries in the EAT. Note that some entries may be 0, indicating that no code/data is exported with that ordinal value.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.NumberOfNames">
            <summary>The number of entries in the Export Names Table (ENT). This value will always be less than or equal to the NumberOf-Functions field. It will be less when there are symbols exported by ordinal only. It can also be less if there are numeric gaps in the assigned ordinals. This field is also the size of the export ordinal table (below).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.AddressOfFunctions">
            <summary>The RVA of the EAT. The EAT is an array of RVAs. Each nonzero RVA in the array corresponds to an exported symbol.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.AddressOfNames">
            <summary>The RVA of the ENT. The ENT is an array of RVAs to ASCII strings. Each ASCII string corresponds to a symbol exported by name. This table is sorted so that the ASCII strings are in order. This allows the loader to do a binary search when looking for an exported symbol. The sorting of the names is binary (like the C++ RTL strcmp function provides), rather than a locale-specific alphabetic ordering.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals">
            <summary>The RVA of the export ordinal table. This table is an array of WORDs. This table maps an array index from the ENT into the corresponding export address table entry.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.TimeDate">
            <summary>The time and date that the export data was created.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_EXPORT_DIRECTORY.Version">
            <summary>Version number</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_BOUND_IMPORT_DESCRIPTOR">
            <summary>Represents the time/date stamp of one imported DLL that has been bound against.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_IMPORT_DESCRIPTOR.TimeDateStamp">
            <summary>Contains the time/date stamp of the imported DLL.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_IMPORT_DESCRIPTOR.OffsetModuleName">
            <summary>Offset to a string with the name of the imported DLL. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_IMPORT_DESCRIPTOR.NumberOfModuleForwarderRefs">
            <summary>Number of <see cref="T:IMAGE_BOUND_FORWARDER_REF"/> structures that immediately follow this structure.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_BOUND_IMPORT_DESCRIPTOR.TimeDate">
            <summary>Contains the time/date stamp of the imported DLL.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_BOUND_FORWARDER_REF">
            <summary>Forwarded DLL references</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_FORWARDER_REF.TimeDateStamp">
            <summary>Contains the time/date stamp of the imported DLL.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_FORWARDER_REF.OffsetModuleName">
            <summary>Offset to a string with the name of the imported DLL.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BOUND_FORWARDER_REF.Reserved">
            <summary>Reserved</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_BOUND_FORWARDER_REF.TimeDate">
            <summary>Contains the time/date stamp of the imported DLL.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.WIN_CERTIFICATE">
            <summary>This structure encapsulates a signature used in verifying executable files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERTIFICATE.dwLength">
            <summary>Specifies the length, in bytes, of the signature.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERTIFICATE.wRevision">
            <summary>Specifies the certificate revision.</summary>
            <remarks>The only defined certificate revision is WIN_CERT_REVISION_1_0 (0x0100).</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.WIN_CERTIFICATE.wCertificateType">
            <summary>Specifies the type of certificate.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.ImgDelayDescr">
            <summary>Delay Load info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.grAttrs">
            <summary>
            The attributes for this structure.
            Currently, the only flag defined is dlattrRva (1), indicating that the address fields in the structure should be treated as RVAs, rather than virtual addresses.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaDLLName">
            <summary>An RVA to a string with the name of the imported DLL. This string is passed to LoadLibrary.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaHmod">
            <summary>
            An RVA to an HMODULE-sized memory location.
            When the Delayloaded DLL is brought into memory, its HMODULE is stored at this location.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaIAT">
            <summary>
            An RVA to the Import Address Table for this DLL.
            This is the same format as a regular IAT.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaINT">
            <summary>
            An RVA to the Import Name Table for this DLL.
            This is the same format as a regular INT.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaBoundIAT">
            <summary>
            An RVA of the optional bound IAT.
            An RVA to a bound copy of an Import Address Table for this DLL.
            This is the same format as a regular IAT.
            Currently, this copy of the IAT is not actually bound, but this feature may be added in future versions of the BIND program.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.rvaUnloadIAT">
            <summary>
            An RVA of the optional copy of the original IAT.
            An RVA to an unbound copy of an Import Address Table for this DLL.
            This is the same format as a regular IAT. Currently always set to 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.ImgDelayDescr.dwTimeStamp">
            <summary>0 if not bound, O.W. date/time stamp of DLL bound to (Old BIND)</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.ImgDelayDescr.TimeStamp">
            <summary>0 if not bound, O.W. date/time stamp of DLL bound to (Old BIND)</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.ImgDelayDescr.IsEmpty">
            <summary>Empty structure</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.IMAGE_BASE_RELOCATION">
            <summary>Based relocation format</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BASE_RELOCATION.VirtualAddress">
            <summary>
            This field contains the starting RVA for this chunk of relocations.
            The offset of each relocation that follows is added to this value to form the actual RVA where the relocation needs to be applied.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.IMAGE_BASE_RELOCATION.SizeOfBlock">
            <summary>
            The size of this structure plus all the WORD relocations that follow.
            To determine the number of relocations in this block, subtract the size of an IMAGE_BASE_RELOCATION (8 bytes) from the value of this field, and then divide by 2 (the size of a WORD).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.IMAGE_BASE_RELOCATION.TypeOffest">
            <summary>Relocation type offset</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.LoadConfig">
            <summary>Load config headers</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32">
            <summary>Load Configuration Directory Entry</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms680328%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.Size">
            <summary>The size of the structure. For Windows XP, the size must be specified as 64 for x86 images.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.TimeDateStamp">
            <summary>
            The date and time stamp value.
            The value is represented in the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Universal Coordinated Time, according to the system clock.
            The time stamp can be printed using the C run-time (CRT) function ctime.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.MajorVersion">
            <summary>The major version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.MinorVersion">
            <summary>The minor version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.GlobalFlagsClear">
            <summary>The global flags that control system behavior. For more information, see Gflags.exe.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.GlobalFlagsSet">
            <summary>The global flags that control system behavior. For more information, see Gflags.exe.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.CriticalSectionDefaultTimeout">
            <summary>The critical section default time-out value.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.DeCommitFreeBlockThreshold">
            <summary>The size of the minimum block that must be freed before it is freed (de-committed), in bytes. This value is advisory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.DeCommitTotalFreeThreshold">
            <summary>
            The size of the minimum total memory that must be freed in the process heap before it is freed (de-committed), in bytes.
            This value is advisory.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.LockPrefixTable">
            <summary>
            The VA of a list of addresses where the LOCK prefix is used.
            These will be replaced by NOP on single-processor systems.
            This member is available only for x86.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.MaximumAllocationSize">
            <summary>The maximum allocation size, in bytes. This member is obsolete and is used only for debugging purposes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.VirtualMemoryThreshold">
            <summary>The maximum block size that can be allocated from heap segments, in bytes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.ProcessAffinityMask">
            <summary>The process affinity mask. For more information, see GetProcessAffinityMask. This member is available only for .exe files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.ProcessHeapFlags">
            <summary>The process heap flags. For more information, see HeapCreate.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.CSDVersion">
            <summary>The service pack version.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.Reserved1">
            <summary>Reserved for use by the operating system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.EditList">
            <summary>Reserved for use by the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.SecurityCookie">
            <summary>A pointer to a cookie that is used by Visual C++ or GS implementation.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.SEHandlerTable">
            <summary>The VA of the sorted table of RVAs of each valid, unique handler in the image. This member is available only for x86.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.SEHandlerCount">
            <summary>The count of unique handlers in the table. This member is available only for x86.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.TimeDate">
            <summary>The date and time stamp value.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY32.Version">
            <summary>Version number</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64">
            <summary>Load Configuration Directory Entry</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/windows/desktop/ms680328%28v=vs.85%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.Size">
            <summary>The size of the structure. For Windows XP, the size must be specified as 64 for x86 images.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.TimeDateStamp">
            <summary>
            The date and time stamp value.
            The value is represented in the number of seconds elapsed since midnight (00:00:00), January 1, 1970, Universal Coordinated Time, according to the system clock.
            The time stamp can be printed using the C run-time (CRT) function ctime.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.MajorVersion">
            <summary>The major version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.MinorVersion">
            <summary>The minor version number.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.GlobalFlagsClear">
            <summary>The global flags that control system behavior. For more information, see Gflags.exe.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.GlobalFlagsSet">
            <summary>The global flags that control system behavior. For more information, see Gflags.exe.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.CriticalSectionDefaultTimeout">
            <summary>The critical section default time-out value.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.DeCommitFreeBlockThreshold">
            <summary>The size of the minimum block that must be freed before it is freed (de-committed), in bytes. This value is advisory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.DeCommitTotalFreeThreshold">
            <summary>
            The size of the minimum total memory that must be freed in the process heap before it is freed (de-committed), in bytes.
            This value is advisory.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.LockPrefixTable">
            <summary>
            The VA of a list of addresses where the LOCK prefix is used.
            These will be replaced by NOP on single-processor systems.
            This member is available only for x86.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.MaximumAllocationSize">
            <summary>The maximum allocation size, in bytes. This member is obsolete and is used only for debugging purposes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.VirtualMemoryThreshold">
            <summary>The maximum block size that can be allocated from heap segments, in bytes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.ProcessAffinityMask">
            <summary>The process affinity mask. For more information, see GetProcessAffinityMask. This member is available only for .exe files.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.ProcessHeapFlags">
            <summary>The process heap flags. For more information, see HeapCreate.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.CSDVersion">
            <summary>The service pack version.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.Reserved1">
            <summary>Reserved for use by the operating system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.EditList">
            <summary>Reserved for use by the system.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.SecurityCookie">
            <summary>A pointer to a cookie that is used by Visual C++ or GS implementation.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.SEHandlerTable">
            <summary>The VA of the sorted table of RVAs of each valid, unique handler in the image. This member is available only for x86.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.SEHandlerCount">
            <summary>The count of unique handlers in the table. This member is available only for x86.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.TimeDate">
            <summary>The date and time stamp value.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.LoadConfig.IMAGE_LOAD_CONFIG_DIRECTORY64.Version">
            <summary>Version number</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Tls">
            <summary>Tls headers</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32">
            <remarks>
            It's important to note that the addresses in the IMAGE_TLS_DIRECTORY structure are virtual addresses, not RVA's.
            Thus, they will get modified by base relocations if the executable doesn't load at its preferred load address.
            Also, the IMAGE_TLS_DIRECTORY itself is not in the .tls section; it resides in the .rdata section.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.StartAddressOfRawDataVA">
            <summary>The beginning address of a range of memory used to initialize a new thread's TLS data in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.EndAddressOfRawDataVA">
            <summary>The ending address of the range of memory used to initialize a new thread's TLS data in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.AddressOfIndex">
            <summary>
            When the executable is brought into memory and a .tls section is present, the loader allocates a TLS handle via TlsAlloc.
            It stores the handle at the address given by this field. The runtime library uses this index to locate the thread local data.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.AddressOfCallBacks">
            <summary>
            Address of an array of PIMAGE_TLS_CALLBACK function pointers.
            When a thread is created or destroyed, each function in the list is called.
            The end of the list is indicated by a pointer-sized variable set to 0.
            In normal Visual C++ executables, this list is empty.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.SizeOfZeroFill">
            <summary>
            The size in bytes of the initialization data, beyond the initialized data delimited by the StartAddressOfRawData and EndAddressOfRawData fields.
            All per-thread data after this range is initialized to 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY32.Characteristics">
            <summary>Reserved for possible future use by TLS flags.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64">
            <remarks>
            It's important to note that the addresses in the IMAGE_TLS_DIRECTORY structure are virtual addresses, not RVA's.
            Thus, they will get modified by base relocations if the executable doesn't load at its preferred load address.
            Also, the IMAGE_TLS_DIRECTORY itself is not in the .tls section; it resides in the .rdata section.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.StartAddressOfRawDataVA">
            <summary>The beginning address of a range of memory used to initialize a new thread's TLS data in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.EndAddressOfRawDataVA">
            <summary>The ending address of the range of memory used to initialize a new thread's TLS data in memory.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.AddressOfIndex">
            <summary>
            When the executable is brought into memory and a .tls section is present, the loader allocates a TLS handle via TlsAlloc.
            It stores the handle at the address given by this field. The runtime library uses this index to locate the thread local data.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.AddressOfCallBacks">
            <summary>
            Address of an array of PIMAGE_TLS_CALLBACK function pointers.
            When a thread is created or destroyed, each function in the list is called.
            The end of the list is indicated by a pointer-sized variable set to 0.
            In normal Visual C++ executables, this list is empty.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.SizeOfZeroFill">
            <summary>
            The size in bytes of the initialization data, beyond the initialized data delimited by the StartAddressOfRawData and EndAddressOfRawData fields.
            All per-thread data after this range is initialized to 0.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Tls.IMAGE_TLS_DIRECTORY64.Characteristics">
            <summary>Reserved for possible future use by TLS flags.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug">
            <summary>Debug information headers</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70">
            <summary>PDB v7 Info</summary>
            <remarks>Note that the structure does not include Offset field (and thus does not start with CV_HEADER structure), while CodeView signature is still present. The absence of Offset field makes this structure an unusual member of CodeView family.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.PDB70Signature">
            <summary>CodeView signature, equal to "RSDS" </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.CvSignature">
            <summary>CodeView signature, equal to "RSDS" </summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.firstPart">
            <summary>Signature first part</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.secondPart">
            <summary>Signature second part</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.thirdPart">
            <summary>Signature third part</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.fourthPart">
            <summary>Signature fourth part</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.Age">
            <summary>Ever-incrementing value, which is initially set to 1 and incremented every time when a part of the PDB file is updated without rewriting the whole file.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.IsValid">
            <summary>PDV v7 signature is valid</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.CvSigString">
            <summary>CodeView signature, equal to "RSDS"</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70.Signature">
            <summary>A unique identifier, which changes with every rebuild of the executable and PDB file.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug.CV_HEADER">
            <summary>CodeView PDB v2 header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_HEADER.PDB20Signature">
            <summary>CodeView sugnature, equal to "NB10"</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_HEADER.Signature">
            <summary>CodeView signature, equals to "NB10"</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_HEADER.Offset">
            <summary>CodeView offset. Set to 0, because debug information is stored in a separate file. </summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_HEADER.IsValid">
            <summary>PDV v2 signature is valid</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_HEADER.CvSigString">
            <summary>CodeView signature, equals to "NB10"</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20">
            <summary>PDB v2 Info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20.CvHeader">
            <summary>PDB v2 Header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20.Signature">
            <summary>The time when debug information was created (in seconds since 01.01.1970)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20.Age">
            <summary>Ever-incrementing value, which is initially set to 1 and incremented every time when a part of the PDB file is updated without rewriting the whole file.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20.TimeDate">
            <summary>The time when debug information was created</summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC_TYPE">
            <summary>Type of misc data</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC_TYPE.EXENAME">
            <summary></summary>
        </member>
        <member name="T:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC">
            <summary>Misc debug Info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC.DataType">
            <summary>Type of misc data, see defines.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC.Length">
            <summary>Total length of record, rounded to four byte multiple.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC.Unicode">
            <summary>TRUE if data is unicode string.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.WinNT.Debug.IMAGE_DEBUG_MISC.Reserved">
            <summary>Reserved</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ExceptionTable">
            <summary>Exception table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ExceptionTable.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of exception table class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ExceptionTable.GetEnumerator">
            <summary>Get all exception procedure pointers</summary>
            <returns>Entries</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ExceptionTable.FirstEntry">
            <summary>First entry in exception table directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaRow">
            <summary>MetaTable row class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaTable,System.UInt32,AlphaOmega.Debug.CorDirectory.Meta.MetaCell[])">
            <summary>Create instance of MetaTable rows class</summary>
            <param name="table">Owner table</param>
            <param name="index">Row index</param>
            <param name="cells">Row cells array</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.GetEnumerator">
            <summary>Get all cells from current row</summary>
            <returns>Cells array</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.Index">
            <summary>Row index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.Table">
            <summary>Parent table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.Cells">
            <summary>Get all cells in this row</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.Item(AlphaOmega.Debug.CorDirectory.Meta.MetaColumn)">
            <summary>Get cell by column</summary>
            <param name="column">MetaTable column</param>
            <exception cref="T:ArgumentException">Column not from this table</exception>
            <returns>Table cell</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaRow.Item(System.UInt32)">
            <summary>Get table cell by column index</summary>
            <param name="columnIndex">Column index</param>
            <exception cref="T:ArgumentOutOfRangeException">columnIndex out of row columns</exception>
            <returns>Table cell</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Debug">
            <summary>Debug directory class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Debug.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of debug directory</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Debug.FindDebugType(AlphaOmega.Debug.WinNT.IMAGE_DEBUG_TYPE)">
            <summary>Find debug header by type</summary>
            <param name="type">Type of debug header</param>
            <returns>Found header or null</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Debug.GetEnumerator">
            <summary>Get all headers in directory</summary>
            <returns>Debug header</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Debug.Pdb2CodeView">
            <summary>CodeView PDB v2 Header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Debug.Pdb7CodeView">
            <summary>CodeView PDB v7 Header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Debug.Misc">
            <summary>Debug misc header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Debug.Count">
            <summary>Количество массивов в директории</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceString">
            <summary>String resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceString.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of string resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceString.GetEnumerator">
            <summary>Get all strings from resource directory</summary>
            <returns>Strings from resource</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodPtrRow">
            <summary>A class-to-methods lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodPtrRow.Method">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldPtrRow">
            <summary>A class-to-fields lookup table, whitch does not exist on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldPtrRow.Field">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow">
            <summary>
            Exported type descriptors that contain information about public classes exported by the current assembly, whitch are declared in other modules of the assembly.
            Only the prime module of the assembly sould carry this table.
            </summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.ToString">
            <summary>TypeNamespace+"."+TypeName</summary>
            <returns>String</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.Flags">
            <summary>Specifies type attributes.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.TypeDefId">
            <summary>
            A 4-byte index into a TypeDef table of another module in this Assembly).
            This column is used as a hint only.
            If the entry in the target TypeDef table matches the TypeName and TypeNamespace entries in this table, resolution has succeeded.
            But if there is a mismatch, the CLI shall fall back to a search of the target TypeDef table.
            Ignored and should be zero if Flags has IsTypeForwarder set.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.TypeName">
            <summary>Type name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.TypeNamespace">
            <summary>Type namespace</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ExportedTypeRow.Implementation">
            <summary>
            This is an index (more precisely, an Implementation (§II.24.2.6) coded index) into either of the following tables:
            	File table, where that entry says which module in the current assembly holds the TypeDef
            	ExportedType table, where that entry is the enclosing Type of the current nested Type.
            	AssemblyRef table, where that entry says in which assembly the type may now be found (Flags must have the IsTypeForwarder flag set).
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.CustomAttributeRow">
            <summary>
            The CustomAttribute table stores data that can be used to instantiate a Custom Attribute
            (more precisely, an object of the specified Custom Attribute class) at runtime.
            The column called Type is slightly misleading —
            it actually indexes a constructor method — the owner of that constructor method
            is the Type of the Custom Attribute.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.CustomAttributeRow.Parent">
            <summary>An index into a metadata table that has an associated HasCustomAttribute (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.CustomAttributeRow.Type">
            <summary>An index into the MethodDef or MemberRef table; more precisely, a CustomAttributeType (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.CustomAttributeRow.Value">
            <summary>Attribute value</summary>
            <remarks>All binary values are stored in little-endian format (except for PackedLen items, which are used only as a count for the number of bytes to follow in a UTF8 string).</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyProcessorRow">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyProcessorRow.Processor">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyOSRow">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyOSRow.OSPlatformId">
            <summary>A 4-byte constant</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyOSRow.OSMajorVersion">
            <summary>Operating system major version.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyOSRow.OSMinorVersion">
            <summary>Operating system minor version.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyOSRow.OSVersion">
            <summary>Operating system version.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MethodSection">
            <summary>Fat method header section descriptor</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MethodSection.Section">
            <summary>Method header section descriptor</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MethodSection.Fat">
            <summary>Fat exception handling clause</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MethodSection.Small">
            <summary>Small exception handling clause</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn">
            <summary>MetaTable column class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.#ctor(AlphaOmega.Debug.Cor.MetaTableType,AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType,System.String,System.UInt32)">
            <summary>Create instance of MetaTable column class</summary>
            <param name="tableType">Owner table type</param>
            <param name="columnType">Column type</param>
            <param name="columnName">Column name</param>
            <param name="columnIndex">Column index in table</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.IsColumnCellPointer(AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType)">
            <summary>Cell pointer column</summary>
            <param name="type">MetaData column type</param>
            <returns>This column contains cell pointer</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.IsColumnCodedToken(AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType)">
            <summary>Coded token column</summary>
            <param name="type">MetaData column type</param>
            <returns>This column contains coded token</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.ToString">
            <summary>Show column as string</summary>
            <returns>String</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.TableType">
            <summary>Owner table type</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.ColumnType">
            <summary>Column type</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.Name">
            <summary>Column name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.Index">
            <summary>Column index in table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.IsCellPointer">
            <summary>Cell pointer column</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaColumn.IsCodedToken">
            <summary>Coded token column</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.MetaData">
            <summary>.NET MetaData directory class</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.CorDirectoryBase">
            <summary>Base .NET directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.CorDirectoryBase.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor,AlphaOmega.Debug.WinNT.COR20_DIRECTORY_ENTRY)">
            <summary>Create instance of base .NET directory</summary>
            <param name="parent">PE directory</param>
            <param name="directory">.NET directory type</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.CorDirectoryBase.GetData">
            <summary>Get all data from directory</summary>
            <returns>Data from directory</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.CorDirectoryBase.Parent">
            <summary>Parent PE directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.CorDirectoryBase.IsEmpty">
            <summary>Directory is empty</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.CorDirectoryBase.Directory">
            <summary>Data in directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.MetaData.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of MetaData directory class</summary>
            <param name="parent">.NET directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.MetaData.GetEnumerator">
            <summary>Get array of all heaps in MedaData directory</summary>
            <returns>Heaps in MetaData directory</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.Header">
            <summary>MetaData header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.StreamTables">
            <summary>MetaData tables</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.GuidHeap">
            <summary>Guid heap</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.BlobHeap">
            <summary>Bloab heap</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.StringHeap">
            <summary>String heap</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.MetaData.USHeap">
            <summary>User String heap</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.VTable">
            <summary>Function pointers for fixup class</summary>
            <remarks>
            Certain languages, which choose not to follow the common type system runtime model,
            can have virtual functions which need to be represented in a v-table.
            These v-tables are laid out by the compiler, not by the runtime.
            Finding the correct v-table slot and calling indirectly through the value held in that slot
            is also done by the compiler.
            </remarks>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.VTable.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of VTable class</summary>
            <param name="parent">.NET directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.VTable.Header">
            <summary>VTable header</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceBitmap">
            <summary>Bitmap resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceBitmap.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of bitmap resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceBitmap.Header">
            <summary>Bitmap header</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.RelocationSection">
            <summary>Relocation section</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.RelocationSection.#ctor(System.UInt16)">
            <summary>Create instance of relocation section</summary>
            <param name="section">Offset from beggining of directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.RelocationSection.Type">
            <summary>type of relocation</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.RelocationSection.Offset">
            <summary>Offset</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.DebugPdb7">
            <summary>CodeView PDB v7 class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.DebugPdb7.Info">
            <summary>PDB v7 Info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.DebugPdb7.PdbFileName">
            <summary>Null-terminated name of the PDB file. It can also contain full or partial path to the file.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DebugPdb7.#ctor(AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB70,System.String)">
            <summary>Create instance of CodeView PDB v7 class</summary>
            <param name="info">CodeView v7 Info</param>
            <param name="pdbFileName">PDB file name saved in PE file</param>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MemberRefRow">
            <summary>
            The MemberRef table combines two sorts of references, to Methods and to Fields of a class,
            known as "MethodRef" and "FieldRef", respectively.
            </summary>
            <remarks>
            An entry is made into the MemberRef table whenever a reference
            is made in the CIL code to a method or field which is defined in another module or assembly.
            (Also, an entry is made for a call to a method with a VARARG signature,
            even when it is defined in the same module as the call site.)
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MemberRefRow.Class">
            <summary>
            An index into the MethodDef, ModuleRef, TypeDef, TypeRef, or TypeSpec tables;
            more precisely, a MemberRefParent (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MemberRefRow.Name">
            <summary>Memeber name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MemberRefRow.Signature">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventMapRow">
            <summary>The EventMap and Event tables result from putting the .event directive on a class (§II.18).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventMapRow.ParentI">
            <summary>An index into the TypeDef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventMapRow.EventListI">
            <summary>An index into the Event table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventMapRow.Parent">
            <summary>Row from TypeDef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventMapRow.EventList">
            <summary>Rows from Event table.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase">
            <summary>Base class for Cell or CodedToken pointer</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaCell,System.UInt32,AlphaOmega.Debug.Cor.MetaTableType)">
            <summary>Create instance of base cell pointer class</summary>
            <param name="cell">Source cell</param>
            <param name="rowIndex">Target row index</param>
            <param name="tableType">Target table type</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.ToString">
            <summary>Display type of the class and type of referenced table</summary>
            <returns>String</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.Cell">
            <summary>Source cell</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.RowIndex">
            <summary>Row index in target table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.TableType">
            <summary>Target table type</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.TargetTable">
            <summary>Target table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.CellPointerBase.TargetRow">
            <summary>Target row</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDirectory">
            <summary>Директория ресурсов</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDirectory.#ctor(AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY,AlphaOmega.Debug.NTDirectory.Resource)">
            <summary>Create instance of resource root directory class</summary>
            <param name="entry">Directory description</param>
            <param name="root">PE directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDirectory.#ctor(AlphaOmega.Debug.WinNT.Resource.IMAGE_RESOURCE_DIRECTORY_ENTRY,AlphaOmega.Debug.NTDirectory.Resource,AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of resource directory class</summary>
            <param name="entry">Directory description</param>
            <param name="root">PE directory</param>
            <param name="parent">Parent directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDirectory.GetData">
            <summary>Get all data in directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDirectory.GetEnumerator">
            <summary>Получить список всех поддиректорий к текущей директории</summary>
            <returns>Список поддиректорий</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.Root">
            <summary>Корневой узел ресурсов</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.Parent">
            <summary>Родительская директория к текущей директории</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.DirectoryEntry">
            <summary>Directory description</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.Directory">
            <summary>Описатель директории</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.Name">
            <summary>Наименование директории</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDirectory.DataEntry">
            <summary>Описание данных</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ExportFunction">
            <summary>Export function description</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ExportFunction.Ordinal">
            <summary>Ordinal function index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ExportFunction.Name">
            <summary>Function name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ExportFunction.Address">
            <summary>Function address</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.StringHeap">
            <summary>String heap class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.StringHeap.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of String heap class</summary>
            <param name="meta">MetaData directory</param>
            <param name="header">.NET stream header</param>
            <exception cref="T:InvalidOperationException">StringHeap class can only read String heap</exception>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StringHeap.Item(System.Int32)">
            <summary>Get string from string heap</summary>
            <param name="index">String index in the heap</param>
            <returns>String from heap</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.StringHeap.Data">
            <summary>All strings from heap</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Iat">
            <summary>Impot Address Table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Iat.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of IAT class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Iat.GetEnumerator">
            <summary>Get pointers array from directory</summary>
            <returns>Array of pointers</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Iat.Count">
            <summary>Pointer count in the directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.DelayImportModule">
            <summary>Delay import module description</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DelayImportModule.#ctor(AlphaOmega.Debug.NTDirectory.DelayImport,AlphaOmega.Debug.WinNT.ImgDelayDescr)">
            <summary>Create instance of delay import module description class</summary>
            <param name="directory">PE directory</param>
            <param name="descriptor">Base info</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DelayImportModule.GetIntAddress">
            <summary>Получить список адресов, по которым можно получить наименования процедур, которые будут импортированы из модуля</summary>
            <exception cref="T:NotImplementedException">Unknown address type specified</exception>
            <returns>Массив адресов</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DelayImportModule.GetEnumerator">
            <summary>Get Import Name Table array</summary>
            <returns>Массив импортируемых процедур</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.DelayImportModule.Directory">
            <summary>PE directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.DelayImportModule.Descriptor">
            <summary>Delay load descriptor</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.DelayImportModule.ModuleName">
            <summary>Name of the imported DLL</summary>
            <exception cref="T:NotImplementedException">Unknown address type specified</exception>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.DelayImportModule.ImageBase">
            <summary>Базовый адрес PE файла.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.ResourceTable">
            <summary>Managed resource table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.ResourceTable.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of managed resource class</summary>
            <param name="parent">NT directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.ResourceTable.GetEnumerator">
            <summary>Get all metadata table rows that contains files in this directory</summary>
            <returns>ManifestResource table rows</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.ResourceTable.DecodeInt(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>Decode 7bit encoded Int</summary>
            <param name="offset">Ofsset from resource_manager header</param>
            <param name="value"></param>
            <param name="size"></param>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.ResourceTable.Header">
            <summary>Managed resource header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.ResourceTable.RuntimeHeader">
            <summary>Resource header</summary>
            <exception cref="T:InvalidOperationException">Managed resource header is invalid</exception>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyMapRow">
            <summary>The PropertyMap and Property tables result from putting the .property directive on a class (§II.17).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyMapRow.ParentI">
            <summary>An index into the TypeDef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyMapRow.PropertyListI">
            <summary>An index into the Property table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyMapRow.Parent">
            <summary>Parent TypeDef table row.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyMapRow.Properties">
            <summary>Property table list</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaCell">
            <summary>MetaTable cell</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaTable,AlphaOmega.Debug.CorDirectory.Meta.MetaColumn,System.UInt32,System.IO.BinaryReader)">
            <summary>Create instance of MetaTable cell class</summary>
            <param name="table">Owner table</param>
            <param name="column">Owner column</param>
            <param name="rowIndex">Owner row index</param>
            <param name="reader">Image reader pointed to cell value</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.ToString">
            <summary>Convert cell value to String</summary>
            <returns>value converted to string</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.Table">
            <summary>Owner table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.Column">
            <summary>Owner column</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.RowIndex">
            <summary>Cell row index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.Value">
            <summary>Cell value</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaCell.RawValue">
            <summary>Original value from PE file</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Tls">
            <summary>Thread Local Storage directory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Tls.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of TLS class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Tls.TlsDirectory32">
            <summary>TLS PE directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Tls.TlsDirectory64">
            <summary>TLS PE+ directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion">
            <summary>Version resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of version resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.GetFileInfo">
            <summary>Get version tables</summary>
            <returns>Extended file description</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.GetVersionTable(AlphaOmega.Debug.BytesReader,AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTableType,System.UInt32@)">
            <summary>Gets version table from PE/PE+ resources</summary>
            <param name="reader">Mapped bytes</param>
            <param name="type">Type of version table</param>
            <param name="padding">Base padding</param>
            <exception cref="T:NotImplementedException">Unknown table row type</exception>
            <returns>Readed version table</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.GetBinaryVersionItem(AlphaOmega.Debug.BytesReader,AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable,System.UInt32@)">
            <summary>Получить элемент версии в сохранённый в бинарном виде</summary>
            <param name="reader">Allocated bytes in memory</param>
            <param name="item">Version table</param>
            <param name="padding">Отступ от начала массива</param>
            <returns>Элемент версии</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionInfo">
            <summary>Default version info</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceVersion.FileInfo">
            <summary>Extended version info</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTableType">
            <summary>Тип таблицы</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTableType.StringFileInfo">
            <summary>Таблица со строковыми данными</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTableType.VarFileInfo">
            <summary>Таблица с бинарными данными</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion.Translation">
            <summary>PE file base language</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.Translation.langID">
            <summary>Language ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.Translation.charsetID">
            <summary>CodePage</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.Translation.ToString">
            <summary>Convert language to string</summary>
            <exception cref="T:NotImplementedException">Unknown langID</exception>
            <returns>String</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionData">
            <summary>Tables group</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionData.Info">
            <summary>PE structure</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionData.szKey">
            <summary>Type of group (Text or Bin)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionData.Items">
            <summary>Tables</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionData.ToString">
            <summary>Type of table</summary>
            <returns>String</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable">
            <summary>Table of values</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable.Table">
            <summary>PE structure</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable.szKey">
            <summary>Name of the table</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable.Items">
            <summary>Values</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionTable.ToString">
            <summary>Table name</summary>
            <returns>String</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionItem">
            <summary>Value info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionItem.Item">
            <summary>PE structure</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionItem.szKey">
            <summary>Name of the item</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionItem.Value">
            <summary>Value</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceVersion.VersionItem.ToString">
            <summary>Convert value to string</summary>
            <exception cref="T:NotImplementedException">Don't now how to convert version item to string</exception>
            <returns>String</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType">
            <summary>MetaData column type</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Module">
            <summary>Module descriptor.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.TypeRef">
            <summary>Class reference descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.TypeDef">
            <summary>Class or interface definition descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Field">
            <summary>A field definition descriptos.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MethodDef">
            <summary>Method definition descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Param">
            <summary>Parameter definition descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.InterfaceImpl">
            <summary>Interface implementation descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MemberRef">
            <summary>Member (field or method) reference descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.DeclSecurity">
            <summary>Security descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.StandAloneSig">
            <summary>Stand-alone signature descriptors. Signatures per se are used in two capacities: as composite signatures of local variables of methods and as parameters of the call indirect (calli) IL instruction.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Event">
            <summary>Event descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Property">
            <summary>Property descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.ModuleRef">
            <summary>Module reference descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.TypeSpec">
            <summary>Type specification descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Assembly">
            <summary>The current assembly descriptor, whitch sould appear only in the prime moduel metadata.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.AssemblyRef">
            <summary>Assembly reference descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.File">
            <summary>File descriptors that contain information about other files in the current assembly.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.ExportedType">
            <summary>
            Exported type descriptors that contain information about public classes exported by the current assembly, whitch are declared in other modules of the assembly.
            Only the prime module of the assembly sould carry this table.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.ManifestResource">
            <summary>Managed resource descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.GenericParam">
            <summary>Type parameter descriptors for generic (parameterized) classes and methods.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MethodSpec">
            <summary>Generic method instantiation descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.GenericParamConstraint">
            <summary>Descriptors of constraints specified for type parameters of generic classes and methods.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.TypeDefOrRef">
            <summary>These items are compact ways to store a TypeDef, TypeRef or TypeSpec token.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.HasConstant">
            <summary>Field, Param, Property</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.CustomAttributeType">
            <summary>MethodDef, MemberRef</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.HasSemantic">
            <summary>Event, Property</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.ResolutionScope">
            <summary>Module, ModuleRef, AssemblyRef, TypeRef</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.HasFieldMarshal">
            <summary>Field, Param</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.HasDeclSecurity">
            <summary>TypeDef, MethodDef, Assembly</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MemberRefParent">
            <summary>TypeDef, TypeRef, ModuleRef, MethodDef, TypeSpec</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MethodDefOrRef">
            <summary>MethodDef, MemberRef</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.MemberForwarded">
            <summary>Field, MethodDef</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Implementation">
            <summary>File, AssemblyRef, ExportedType</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.HasCustomAttribute">
            <summary>MethodDef, Field, TypeRef, TypeDef, Param, InterfaceImpl, MemberRef, Module, Permission, Property, Event, StandAloneSig, ModuleRef, TypeSpec, Assembly, AssemblyRef, File, ExportedType, ManifestResource, GenericParam, GenericParamConstraint, MethodSpec</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.TypeOrMethodDef">
            <summary>TypeDef, MethodDef</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.UInt16">
            <summary>UInt16</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.UInt32">
            <summary>UInt32</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.String">
            <summary>String</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Blob">
            <summary>Blob</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.Guid">
            <summary>Guid</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType.UserString">
            <summary>UserString</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow">
            <summary>
            Properties within metadata are best viewed as a means
            to gather together collections of methods defined on a class, give them a name, and not much else.
            The methods are typically get_ and set_ methods, already defined on the class,
            and inserted like any other methods into the MethodDef table.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.Flags">
            <summary>Flags that can be associated with a property.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.Name">
            <summary>Property name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.Type">
            <summary>Signature</summary>
            <remarks>
            The name of this column is misleading.
            It does not index a TypeDef or TypeRef table — instead it indexes the signature in the Blob heap of the Property.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.PropertySig">
            <summary>First byte of signature</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.ParamCount">
            <summary>Count of input parameters for this property</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyRow.ReturnType">
            <summary>Property type</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ENCLogRow">
            <summary>
            Edit-and-continue log descriptors that hold information about what changes have been made to specific metadata items during in-memory editing.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ENCLogRow.Token">
            <summary>Banana</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ENCLogRow.FuncCode">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaCellCodedToken">
            <summary>Coded Token class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaCellCodedToken.CodedTokenBits">
            <summary>Number of bits in coded token tag for a coded token that refers to n tables.</summary>
            <remarks>values 5-17 are not used :I</remarks>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaCellCodedToken.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaCell,System.UInt32)">
            <summary>Create instance of coded token class</summary>
            <param name="cell">Source cell</param>
            <param name="rawValue">Original value from PE file</param>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.BoundImport">
            <summary>Bound import class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.BoundImport.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of bound import class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.BoundImport.GetEnumerator">
            <summary></summary>
            <returns></returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.BoundImport.Descriptor">
            <summary>Header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.BoundImport.ModuleName">
            <summary>Module name whitch this image is bounded</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.BoundImport.IsEmpty">
            <summary>Directory is empty</summary>
        </member>
        <member name="T:AlphaOmega.Debug.LookupLoader">
            <summary>Test loader</summary>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.#ctor(System.String)">
            <summary>Create instance of test loader</summary>
            <param name="filePath"></param>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.PtrToStructure``1(System.UInt32)">
            <summary>Get structure from specific padding from the beginning of the image</summary>
            <typeparam name="T">Structure type</typeparam>
            <param name="padding">Padding from the beginning of the image</param>
            <returns>Readed structure from image</returns>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Get bytes from specific padding and specific length</summary>
            <param name="padding">Padding from the beginning of the image</param>
            <param name="length">Length of bytes to read</param>
            <returns>Readed bytes</returns>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.PtrToStringAnsi(System.UInt32)">
            <summary>Get ACSII string from specific padding from the beginning of the image</summary>
            <param name="padding">Padding from the beginning of the image</param>
            <returns>String from pointer</returns>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.Dispose">
            <summary>Save to text file all data that was readed</summary>
        </member>
        <member name="M:AlphaOmega.Debug.LookupLoader.GetFileUniqueName(System.String,System.String,System.UInt32)">
            <summary>Получить уникальное наименование файла</summary>
            <param name="path">Путь с наименованием файла</param>
            /// <param name="extension">Расширение, которое добавляется к файлу</param>
            <param name="index">Индекс наименования, если файл с таким наименованием уже существует</param>
            <returns>Уникальное наимеование файла</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSemanticsRow">
            <summary>
            The rows of the MethodSemantics table are filled by .property (§II.17) and .event directives (§II.18).
            (See §II.22.13 for more information.)
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSemanticsRow.Semantic">
            <summary>2-byte bitmask of type MethodSemanticsAttributes, §II.23.1.12.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSemanticsRow.MethodI">
            <summary>An index into the MethodDef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSemanticsRow.Association">
            <summary>An index into the Event or Property table; more precisely, a HasSemantics (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSemanticsRow.Method">
            <summary>MethodDef table row</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow">
            <summary>
            Each row in the Field table results from a top-level .field directive (§II.5.10),
            or a .field directive inside a Type (§II.10.2). (For an example, see §II.14.5.).
            </summary>
            <remarks>
            Conceptually, each row in the Field table is owned by one, and only one, row in the TypeDef table.
            However, the owner of any row in the Field table is not stored anywhere in the Field table itself.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow.Flags">
            <summary>A 4-byte bit mask of type TypeAttributes.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow.Name">
            <summary>Field Name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow.Signature">
            <summary>Banana</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow.FieldSig">
            <summary>First byte of signature</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRow.ReturnType">
            <summary>Field type</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero.
            They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.OSPlatformId">
            <summary>A 4-byte constant</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.OSMajorVersion">
            <summary>Operating system major version.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.OSMinorVersion">
            <summary>Operating system minor version.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.AssemblyRefI">
            <summary>An index into the AssemblyRef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.OSVersion">
            <summary>Operating system version.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefOSRow.AssemblyRef">
            <summary>AssemblyRef table row.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaCellPointer">
            <summary>Pointer to anoter table cell</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaCellPointer.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaCell,System.UInt32)">
            <summary>Create instance of pointer cell</summary>
            <param name="cell">Source cell</param>
            <param name="rawValue">Original value from PE file</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaCellPointer.GetTargetRowsIt">
            <summary>Получить в итерации ряды с индекса на который указывает текущий указатель</summary>
            <remarks>Метод специфичен для определённых таблиц. Поэтому переносить в базовый класс - бессмысленно</remarks>
            <returns>Target rows array</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ImportModule">
            <summary>Import description class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ImportModule.#ctor(AlphaOmega.Debug.NTDirectory.Import,AlphaOmega.Debug.WinNT.IMAGE_IMPORT_DESCRIPTOR)">
            <summary>Create instance of import description class</summary>
            <param name="directory">Import directory</param>
            <param name="header">Header</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ImportModule.GetEnumerator">
            <summary>Get all import procedures from module</summary>
            <returns>Import procedures</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ImportModule.GetImageImport(System.UInt32,System.Boolean)">
            <summary>Получить информацию по импорту</summary>
            <param name="offset">Сдвиг по PE файлу</param>
            <param name="isRva">Получить импорт по Relative Virtual Address адресу. В противном случае передаётся Virtual Address</param>
            <returns>Структура</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ImportModule.Header">
            <summary>Import directory header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ImportModule.ModuleName">
            <summary>Name of the imported module</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor">
            <summary>Структуры .NET Framework</summary>
            <remarks>Описание в CorHdr.h</remarks>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1">
            <summary>Метаданные .NET сборки</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.Signature">
            <summary>Magic signature for physical metadata : 0x424A5342.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.MajorVersion">
            <summary>Major version, 1 (ignore on read).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.MinorVersion">
            <summary>Minor version, 1 (ignore on read).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.Reserved">
            <summary>Reserved, always 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.Length">
            <summary>Length of version string in bytes, say  m (&lt;= 255), rounded up to a multiple of four.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA1.IsValid">
            <summary>MetaData signature is valid</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA2.Flags">
            <summary>Reserved, always 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA2.Streams">
            <summary>Number of streams, say n.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA">
            <summary>
            The root of the physical metadata starts with a magic signature,
            several bytes of version and other miscellaneous information,
            followed by a count and an array of stream headers, one for each stream that is present.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Signature">
            <summary>Magic signature for physical metadata : 0x424A5342.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.MajorVersion">
            <summary>Major version, 1 (ignore on read).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.MinorVersion">
            <summary>Minor version, 1 (ignore on read).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Reserved">
            <summary>Reserved, always 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Length">
            <summary>Length of version string in bytes, say  m (&lt;= 255), rounded up to a multiple of four.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Version">
            <summary>UTF8-encoded version string of length m (see below).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Flags">
            <summary>Reserved, always 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.Streams">
            <summary>Number of streams, say n.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.IsValid">
            <summary>MetaData header valid</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.SignatureStr">
            <summary>String representation of the signature</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.IMAGE_COR20_METADATA.StructVersion">
            <summary>MetaData struct version</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.IMAGE_COR20_VTABLE">
            <summary>
            Each entry in this array describes a contiguous array of v-table slots of the specified size.
            Each slot starts out initialized to the metadata token value for the method they need to call.
            At image load time, the runtime Loader will turn each entry into a pointer to machine code for the CPU and can be called directly.
            </summary>
            <remarks>
            Certain languages, which choose not to follow the common type system runtime model, can have
            virtual functions which need to be represented in a v-table.
            These v-tables are laid out by the compiler, not by the runtime.
            Finding the correct v-table slot and calling indirectly through the value held in that slot is also done by the compiler.
            The VtableFixups field in the runtime header contains the location and size of an array of Vtable Fixups (§II.15.5.1).
            V-tables shall be emitted into a read-write section of the PE file.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_VTABLE.VirtualAddress">
            <summary>RVA of VTable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_VTABLE.Size">
            <summary>Number of entries in VTable.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.IMAGE_COR20_VTABLE.Type">
            <summary>Type of the entries.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.ResourceManagerHeader">
            <summary>Managed resources header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceManagerHeader.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceManagerHeader.MagicNumber">
            <summary>Magic Number (0xBEEFCACE)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceManagerHeader.HeaderVersionNumber">
            <summary>Resource Manager header version</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceManagerHeader.SizeOfReaderType">
            <summary>Num bytes to skip from here to get past this header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.ResourceManagerHeader.IsValid">
            <summary>Header is valid</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.ResourceManagerHeader.MagicNumberStr">
            <summary>Magin number as string</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.ResourceSetHeader">
            <summary>Managed resources header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceSetHeader.Version">
            <summary>Resource set header version</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceSetHeader.NumberOfResources">
            <summary>Number of Resources</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ResourceSetHeader.NumberOfTypes">
            <summary>Number of types</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.COR_VTABLE">
            <summary>Type of the entries.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_VTABLE._32BIT">
            <summary>Vtable slots are 32 bits.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_VTABLE._64BIT">
            <summary>Vtable slots are 64 bits.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_VTABLE.FROM_UNMANAGED">
            <summary>Transition from unmanaged to managed code.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_VTABLE.CALL_MOST_DERIVED">
            <summary>Call most derived method described by the token (only valid for virtual methods).</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.StreamHeaderType">
            <summary>Stream types</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.String">
            <summary>#Strings</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.UnicodeSting">
            <summary>#US</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.Blob">
            <summary>#Blob</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.Guid">
            <summary>#GUID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.StreamTable">
            <summary>#~</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.StreamHeaderType.StreamTableUnoptimized">
            <summary>#-</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.STREAM_HEADER">
            <summary>A stream header gives the names, and the position and length of a particular table or heap.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_HEADER.Offset">
            <summary>Memory offset to start of this stream from start of the metadata root.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_HEADER.Size">
            <summary>Size of this stream in bytes, shall be a multiple of 4.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_HEADER.Name">
            <summary>
            Name of the stream as null-terminated variable length array of ASCII characters, padded to the next 4-byte boundary with \0 characters.
            The name is limited to 32 characters.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_HEADER.Type">
            <summary>Stream header type</summary>
            <exception cref="T:System.NotImplementedException">Stream header type is unknown</exception>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER">
            <summary>.NET Stream table header</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.TablesCount">
            <summary>Кол-во таблиц. В коде Daniel Pistelli было 64, а на самом деле, их 46.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.Reserved1">
            <summary>Reserved, always 0</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.MajorVersion">
            <summary>Major version of table schemata; shall be 2</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.MinorVersion">
            <summary>Minor version of table schemata; shall be 0</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.HeapSizes">
            <summary>Bit vector for heap sizes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.Reserved2">
            <summary>Reserved, always 1</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.Valid">
            <summary>Bit vector of present tables, let n be the number of bits that are 1.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.Sorted">
            <summary>Bit vector of sorted tables.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.IsTablePresent(System.Int32)">
            <summary>If specific table presents in stream</summary>
            <param name="tableIndex">Index of table</param>
            <returns>True/False</returns>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.Version">
            <summary>Version of table schemata</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.StringIndexSize">
            <summary>Size</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.GuidIndexSize">
            <summary>Size</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.BlobIndexSize">
            <summary>Size</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.STREAM_TABLE_HEADER.PresentTablesCount">
            <summary>Count of tables in stream</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethod">
            <summary>Flags for method header.</summary>
            <remarks>
            The first byte of a method header can also contain the following flags,
            valid only for the Fat format, that indicate how the method is to be executed.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod.FatFormat">
            <summary>Method header is fat.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod.TinyFormat">
            <summary>Method header is tiny.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod.MoreSects">
            <summary>More sections follow after this header (§II.25.4.5).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod.InitLocals">
            <summary>Call default constructor on all local variables.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethodHeader">
            <summary>IL method header descriptor</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodHeader.Format">
            <summary>Flags (CorILMethod_FatFormat shall be set in bits 0:1, see §II.25.4.4)</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodHeader.Size">
            <summary>Size of this header expressed as the count of 4-byte integers occupied (currently 3)</summary>
            <remarks>TODO: This must be 12+4bits from structure start</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodHeader.MaxStack">
            <summary>Maximum number of items on the operand stack.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodHeader.CodeSize">
            <summary>Size in bytes of the actual method body.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodHeader.LocalVarSigTok">
            <summary>
            Meta Data token for a signature describing the layout of the local variables for the method.
            0 means there are no local variables present.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodHeader.HeaderSize">
            <summary>Method header size</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethod_Sect">
            <summary>Fat method section descriptor</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod_Sect.EHTable">
            <summary>Exception handling data.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod_Sect.OptILTable">
            <summary>Reserved, shall be 0.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod_Sect.FatFormat">
            <summary>
            Data format is of the fat variety, meaning there is a 3 - byte length least - significant byte first format.
            If not set, the header is small with a 1 - byte length.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethod_Sect.MoreSects">
            <summary>Another data section occurs after this current section.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethodSection">
            <summary>Currently, the method data sections are only used for exception tables (§II.19).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodSection.Kind">
            <summary>Data section type</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodSection.DataSize">
            <summary>Raw data size</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodSection.ClauseNumber">
            <summary>Count of clause numbers</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodSection.IsFatFormat">
            <summary>Section in Fat format.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodSection.HasMoreSections">
            <summary>More sections follow after this one.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.COR_ILEXCEPTION_CLAUSE">
            <summary>Type of exception-handling clause.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_ILEXCEPTION_CLAUSE.EXCEPTION">
            <summary>A typed exception clause.</summary>
            <remarks>
            If the clause is a typed exception clause
            then read the token of the exception that will be handled by it.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_ILEXCEPTION_CLAUSE.FILTER">
            <summary>An exception filter and handler clause.</summary>
            <remarks>
            If the clause is a filter clause then read the offset of the filter.
            (e.g.: VB.NET can generate such filter for the "Catch exc As Exception When value = True" code).
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_ILEXCEPTION_CLAUSE.FINALLY">
            <summary>A finally clause.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.COR_ILEXCEPTION_CLAUSE.FAULT">
            <summary>Fault clause (finally that is called on exception only).</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall">
            <summary>
            The small form of the exception clause should be used whenever the code sizes
            for the try block and the handler code are both smaller than 256 bytes and both their offsets are smaller than 65536.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.TryOffset">
            <summary>Offset in bytes of try block from start of method body.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.TryLength">
            <summary>Length in bytes of the try block.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.HandlerOffset">
            <summary>Location of the handler for this try block.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.HandlerLength">
            <summary>Size of the handler code in bytes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.ClassTokenOrFilterOffset">
            <summary>
            Meta data token for a type-based exception handler.
            Or
            Offset in method body for filter-based exception handler.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodExceptionSmall.Flags">
            <summary>Type of exception clause</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.CorILMethodExceptionFat">
            <summary>Fat exception clause header section</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.TryOffset">
            <summary>Offset in bytes of try block from start of method body.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.TryLength">
            <summary>Length in bytes of the try block.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.HandlerOffset">
            <summary>Location of the handler for this try block.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.HandlerLength">
            <summary>Size of the handler code in bytes.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.ClassTokenOrFilterOffset">
            <summary>
            Meta data token for a type-based exception handler.
            Or
            Offset in method body for filter-based exception handler.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.Cor.CorILMethodExceptionFat.Flags">
            <summary>Type of exception clause</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.ELEMENT_TYPE">
            <summary>Specifies a common language runtime Type, a type modifier, or information about a type in a metadata type signature.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms232600%28v=vs.110%29.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.END">
            <summary>Marks end of a list.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.VOID">
            <summary>A void type. <see cref="T:System.Void"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.BOOLEAN">
            <summary>A Boolean type. <see cref="T:System.Boolean"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CHAR">
            <summary>A character type. <see cref="T:System.Char"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.I1">
            <summary>A signed 1-byte integer. <see cref="T:System.SByte"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.U1">
            <summary>An unsigned 1-byte integer. <see cref="T:System.Byte"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.I2">
            <summary>A signed 2-byte integer. <see cref="T:System.Int16"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.U2">
            <summary>An unsigned 2-byte integer. <see cref="T:System.UInt16"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.I4">
            <summary>A signed 4-byte integer. <see cref="T:System.Int32"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.U4">
            <summary>An unsigned 4-byte integer. <see cref="T:System.UInt32"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.I8">
            <summary>A signed 8-byte integer. <see cref="T:System.Int64"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.U8">
            <summary>An unsigned 8-byte integer. <see cref="T:System.UInt64"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.R4">
            <summary>A 4-byte floating point. <see cref="T:System.Single"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.R8">
            <summary>An 8-byte floating point. <see cref="T:System.Double"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.STRING">
            <summary>A System.String type. <see cref="T:System.String"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.PTR">
            <summary>A pointer type modifier.</summary>
            <remarks>Unmanaged pointer, followed by the Type element.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.BYREF">
            <summary>A reference type modifier.</summary>
            <remarks>Managed pointer, followed by the Type element.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.VALUETYPE">
            <summary>A value type modifier.</summary>
            <remarks>A value type modifier, followed by TypeDef or TypeRef token.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CLASS">
            <summary>A class type modifier.</summary>
            <remarks>A class type modifier, followed by TypeDef or TypeRef token.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.VAR">
            <summary>A class variable type modifier.</summary>
            <remarks>Generic parameter in a generic type definition, represented as number.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.ARRAY">
            <summary>A multi-dimensional array type modifier.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.GENERICINST">
            <summary>A type modifier for generic types.</summary>
            <remarks>Generic type instantiation. Followed by type type-arg-count type-1 ... type-n</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.TYPEDBYREF">
            <summary>A typed reference.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.I">
            <summary>Size of a native integer. <see cref="T:System.IntPtr"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.U">
            <summary>Size of an unsigned native integer. <see cref="T:System.UIntPtr"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.FNPTR">
            <summary>A pointer to a function.</summary>
            <remarks>Followed by full method signature.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.OBJECT">
            <summary>A System.Object type. <see cref="T:System.Object"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.SZARRAY">
            <summary>A single-dimensional, zero lower-bound array type modifier.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.MVAR">
            <summary>A method variable type modifier.</summary>
            <remarks>Generic parameter in a generic method definition, represented as number</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CMOD_REQ">
            <summary>A C language required modifier.</summary>
            <remarks>Required modifier, followed by a TypeDef or TypeRef token</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.CMOD_OPT">
            <summary>A C language optional modifier.</summary>
            <remarks>Optional modifier, followed by a TypeDef or TypeRef token</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.INTERNAL">
            <summary>Implemented within the CLI</summary>
            <remarks>Used internally.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.MAX">
            <summary>An invalid type.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.MODIFIER">
            <summary>ORed with following element types</summary>
            <remarks>Used internally.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.SENTINEL">
            <summary>A type modifier that is a sentinel for a list of a variable number of parameters.</summary>
            <remarks>Sentinel for vararg method signature.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.PINNED">
            <summary>Denotes a local variable that points at a pinned object.</summary>
            <remarks>Used internally.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.TYPE">
            <summary>Indicates an argument of type <see cref="T:System.Type"/></summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.BOXED">
            <summary>Used in custom attributes to specify a boxed object (Ecma-335: #II.23.3).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.RESERVED1">
            <summary>Reserved</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.FIELD">
            <summary>Used in custom attributes to indicate a FIELD(Ecma-335: #II.22.10, II.23.3).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.PROPERTY">
            <summary>Used in custom attributes to indicate a PROPERTY (Ecma-335: #II.22.10, II.23.3).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.ELEMENT_TYPE.ENUM">
            <summary>Used in custom attributes to specify an enum (Ecma-335: #II.23.3)</summary>
        </member>
        <member name="T:AlphaOmega.Debug.Cor.MetaTableType">
            <summary>MetaData Table Types</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Module">
            <summary>The rows in the Module table result from .module directives in the Assembly.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.TypeRef">
            <summary>Class reference descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.TypeDef">
            <summary>
            The first row of the TypeDef table represents the pseudo class that acts as parent for functions and variables 
            defined at module scope.
            If a type is generic, its parameters are defined in the GenericParam table (§22.20). Entries in the 
            GenericParam table reference entries in the TypeDef table; there is no reference from the TypeDef table to the 
            GenericParam table.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.FieldPtr">
            <summary>A class-to-fields lookup table, whitch does not exist on optimized metadata (#~ stream).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Field">
            <summary>
            Each row in the Field table results from a top-level .field directive, or a .field directive inside a Type.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MethodPtr">
            <summary>A class-to-methods lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MethodDef">
            <summary>
            Conceptually, every row in the MethodDef table is owned by one, and only one, row in the TypeDef table.
            The rows in the MethodDef table result from .method directives (§15). The RVA column is computed when 
            the image for the PE file is emitted and points to the COR_ILMETHOD structure for the body of the method.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ParamPtr">
            <summary>A method-to-parameters lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Param">
            <summary>
            Conceptually, every row in the Param table is owned by one, and only one, row in the MethodDef table.
            The rows in the Param table result from the parameters in a method declaration (§15.4), or from a .param
            attribute attached to a method.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.InterfaceImpl">
            <summary>Interface implementation descriptors.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MemberRef">
            <summary>
            Combines two sorts of references, to Methods and to Fields of a class, known as 'MethodRef' and 'FieldRef', respectively.
            An entry is made into the MemberRef table whenever a reference is made in the CIL code to a method or field 
            which is defined in another module or assembly.  (Also, an entry is made for a call to a method with a VARARG
            signature, even when it is defined in the same module as the call site.) 
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Constant">
            <summary>Used to store compile-time, constant values for fields, parameters, and properties.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.CustomAttribute">
            <summary>
            Stores data that can be used to instantiate a Custom Attribute (more precisely, an 
            object of the specified Custom Attribute class) at runtime.
            A row in the CustomAttribute table for a parent is created by the .custom attribute, which gives the value of 
            the Type column and optionally that of the Value column.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.FieldMarshal">
            <summary>
            The FieldMarshal table  'links' an existing row in the Field or Param table, to information 
            in the Blob heap that defines how that field or parameter (which, as usual, covers the method return, as 
            parameter number 0) shall be marshalled when calling to or from unmanaged code via PInvoke dispatch.
            A row in the FieldMarshal table is created if the .field directive for the parent field has specified a marshal attribute.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.DeclSecurity">
            <summary>
            The rows of the DeclSecurity table are filled by attaching a .permission or .permissionset directive 
            that specifies the Action and PermissionSet on a parent assembly or parent type or method.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ClassLayout">
            <summary>
            Used to define how the fields of a class or value type shall be laid out by the CLI.
            (Normally, the CLI is free to reorder and/or insert gaps between the fields defined for a class or value type.)
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.FieldLayout">
            <summary>A row in the FieldLayout table is created if the .field directive for the parent field has specified a field offset.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.StandAloneSig">
            <summary>
            Signatures are stored in the metadata Blob heap.  In most cases, they are indexed by a column in some table —
            Field.Signature, Method.Signature, MemberRef.Signature, etc.  However, there are two cases that require a 
            metadata token for a signature that is not indexed by any metadata table.  The StandAloneSig table fulfils this 
            need.  It has just one column, which points to a Signature in the Blob heap.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.EventMap">
            <summary>
            A class-to-events mapping table.
            This is not an intermidate lookup table, and it does not exist in optimized metadata.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.EventPtr">
            <summary>An event map-to-events lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Event">
            <summary>The EventMap and Event tables result from putting the .event directive on a class.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.PropertyMap">
            <summary>The PropertyMap and Property tables result from putting the .property directive on a class.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.PropertyPtr">
            <summary>A property map-to-properties lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Property">
            <summary>Does a little more than group together existing rows from other tables.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MethodSemantics">
            <summary>The rows of the MethodSemantics table are filled by .property and .event directives.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MethodImpl">
            <summary>
            s let a compiler override the default inheritance rules provided by the CLI. Their original use 
            was to allow a class C, that inherited method M from both interfaces I and J, to provide implementations for 
            both methods (rather than have only one slot for M in its vtable). However, MethodImpls can be used for other 
            reasons too, limited only by the compiler writer‘s ingenuity within the constraints defined in the Validation rules.
            ILAsm uses the .override directive to specify the rows of the MethodImpl table.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ModuleRef">
            <summary>The rows in the ModuleRef table result from .module extern directives in the Assembly.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.TypeSpec">
            <summary>
            The TypeSpec table has just one column, which indexes the specification of a Type, stored in the Blob heap.
            This provides a metadata token for that Type (rather than simply an index into the Blob heap).
            This is required, typically, for array operations, such as creating, or calling methods on the array class.
            </summary>
            <remarks>
            Note that TypeSpec tokens can be used with any of the CIL instructions that take a TypeDef or TypeRef token;
            specifically, castclass, cpobj, initobj, isinst, ldelema, ldobj, mkrefany, newarr, refanyval, sizeof, stobj, box, and unbox.
            </remarks>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ImplMap">
            <summary>
            Holds information about unmanaged methods that can be reached from managed code, 
            using PInvoke dispatch. 
            A row is entered in the ImplMap table for each parent Method (§15.5) that is defined with a .pinvokeimpl
            interoperation attribute specifying the MappingFlags, ImportName, and ImportScope.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.FieldRVA">
            <summary>
            Conceptually, each row in the FieldRVA table is an extension to exactly one row in the Field table, and records 
            the RVA (Relative Virtual Address) within the image file at which this field‘s initial value is stored.
            A row in the FieldRVA table is created for each static parent field that has specified the optional data
            label. The RVA column is the relative virtual address of the data in the PE file.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ENCLog">
            <summary>
            Edit-and-continue log descriptors that hold information about what changes have been made to specific metadata items during in-memory editing.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ENCMap">
            <summary>
            Edit-and-continue mapping descriptors.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.Assembly">
            <summary>The current assembly descriptor, whitch sould appear only in the prime moduel metadata.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.AssemblyProcessor">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.AssemblyOS">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.AssemblyRef">
            <summary>
            The table is defined by the .assembly extern directive (§6.3). Its columns are filled using directives 
            similar to those of the Assembly table except for the PublicKeyOrToken column, which is defined using the 
            .publickeytoken directive.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.AssemblyRefProcessor">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.AssemblyRefOS">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero. They should be ignored by the CLI.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.File">
            <summary>The rows of the File table result from .file directives in an Assembly.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ExportedType">
            <summary>
            Holds a row for each type:
            a. Defined within other modules of this Assembly; that is exported out of this Assembly.
            In essence, it  stores TypeDef row numbers of all types that are marked public in other modules that this Assembly comprises.
            The actual target row in a TypeDef table is given by the combination of TypeDefId (in effect, row 
            number) and Implementation (in effect, the module that holds the target TypeDef table). Note that this 
            is the only occurrence in metadata of foreign tokens; that is, token values that have a meaning in 
            another module. (A regular token value is an index into a table in the current module); OR
            b. Originally defined in this Assembly but now moved to another Assembly. Flags must have 
            IsTypeForwarder set and Implementation is an AssemblyRef indicating the Assembly the type may now be found in.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.ManifestResource">
            <summary>The rows in the table result from .mresource directives on the Assembly.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.NestedClass">
            <summary>NestedClass is defined as lexically 'inside' the text of its enclosing Type.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.GenericParam">
            <summary>
            Stores the generic parameters used in generic type definitions and generic method definitions.
            These generic parameters can be constrained (i.e., generic arguments shall extend some class 
            and/or implement certain interfaces) or unconstrained.  (Such constraints are stored in the GenericParamConstraint table.)
            Conceptually, each row in the GenericParam table is owned by one, and only one, row in either the TypeDef or 
            MethodDef tables.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.MethodSpec">
            <summary>
            Records the signature of an instantiated generic method.
            Each unique instantiation of a generic method (i.e., a combination of Method and Instantiation)
            shall be represented by a single row in the table.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.Cor.MetaTableType.GenericParamConstraint">
            <summary>
            Records the constraints for each generic parameter.
            Each generic parameter can be constrained to derive from zero or one class.
            Each generic parameter can be constrained to implement zero or more interfaces.
            Conceptually, each row in the GenericParamConstraint table is owned by a row in the GenericParam table.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDialog">
            <summary>Dialog resource class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDialog.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of dialog resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceDialog.GetDialogTemplate">
            <summary>Get dialog template in resource directory</summary>
            <exception cref="T:NotImplementedException">Class type not implemented</exception>
            <returns>Dialog template from directory</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate">
            <summary>Шаблон диалога</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Version">
            <summary>Template version</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Signature">
            <summary>Signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.helpID">
            <summary>Help ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Styles">
            <summary>Dialog styles</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.StylesEx">
            <summary>Dialog EX styles</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.X">
            <summary>X coordinate</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Y">
            <summary>Y coordinate</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.CX">
            <summary>Width</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.CY">
            <summary>height</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Title">
            <summary>Dialog title</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Font">
            <summary>Dialog font</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Controls">
            <summary>Controls</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.Menu">
            <summary>Dialog menu index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogTemplate.WindowName">
            <summary>WindowName</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate">
            <summary>Шаблон элемента диалога</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.HelpID">
            <summary>Help ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.Styles">
            <summary>Control styles</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.StylesEx">
            <summary>Control extended styles</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.X">
            <summary>X location</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.Y">
            <summary>Y location</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.CX">
            <summary>Width</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.CY">
            <summary>Height</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.ControlID">
            <summary>ID</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.ItemSystemClass">
            <summary>Control system class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.ItemClass">
            <summary>Control COM class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.ItemText">
            <summary>Item title text</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogItemTemplate.ExtraData">
            <summary>Control item extended data</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont">
            <summary>Шрифт</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont.FontSize">
            <summary>Размер шрифта</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont.FontWeight">
            <summary>Толщина шрифта</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont.Italic">
            <summary>Наклонный</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont.CharSet">
            <summary>Character Set</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.DialogFont.TypeFace">
            <summary>Наименование шрифта</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass">
            <summary>Predefined system class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.Button">
            <summary>Button</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.Edit">
            <summary>TextBox</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.Static">
            <summary>Label</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.ListBox">
            <summary>ListBox</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.ScrollBar">
            <summary>ScrollBar</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceDialog.ControlSystemClass.ComboBox">
            <summary>ComboBox</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr">
            <summary>Contains values that describe the relationship between a method and an associated property or event.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms232595.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msSetter">
            <summary>Specifies that the method is a set accessor for a property.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msGetter">
            <summary>Specifies that the method is a get accessor for a property.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msOther">
            <summary>Specifies that the method has a relationship to a property or an event other than those defined here.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msAddOn">
            <summary>Specifies that the method adds handler methods for an event.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msRemoveOn">
            <summary>Specifies that the method removes handler methods for an event.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorMethodSemanticsAttr.msFire">
            <summary>Specifies that the method raises an event.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CorFileFlags">
            <summary>Contains values that describe the type of file defined in a call to IMetaDataAssemblyEmit::DefineFile.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms232970.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorFileFlags.ffContainsMetaData">
            <summary>Indicates that the file is not a resource file.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorFileFlags.ffContainsNoMetaData">
            <summary>Indicates that the file, possibly a resource file, does not contain metadata.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldLayoutRow">
            <summary>
            A row in the FieldLayout table is created if the .field directive
            for the parent field has specified a field offset (§II.16).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldLayoutRow.Offset">
            <summary>A 4-byte constant.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldLayoutRow.FieldI">
            <summary>An index into the Field table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldLayoutRow.Field">
            <summary>Field table row.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ClassLayoutRow">
            <summary>
            The ClassLayout table is used to define how the fields of a class or value type
            shall be laid out by the CLI.
            (Normally, the CLI is free to reorder and/or insert gaps between the fields defined
            for a class or value type.)
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ClassLayoutRow.PackingSize">
            <summary>A 2-byte constant.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ClassLayoutRow.ClassSize">
            <summary>A 4-byte constant</summary>
            <remarks>
            ClassSize of zero does not mean the class has zero size.
            It means that no .size directive was specified at definition time, in which case,
            the actual size is calculated from the field types,
            taking account of packing size (default or specified) and natural alignment on the target,
            runtime platform.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ClassLayoutRow.ParentI">
            <summary>An index into the TypeDef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ClassLayoutRow.Parent">
            <summary>TypeDef table row.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow">
            <summary>
            The Assembly table is defined using the .assembly directive (§II.6.2);
            its columns are obtained from the respective .hash algorithm, .ver, .publickey, and .culture (§II.6.2.1).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.HashAlgId">
            <summary>Specifies all the hash algorithms used for hashing files and for generating the strong name.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.MajorVersion">
            <summary>Assembly major version</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.MinorVersion">
            <summary>Assembly minor version</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.BuildNumber">
            <summary>Assembly build number</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.RevisionNumber">
            <summary>Assembly revision number</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.Flags">
            <summary>MetaData applied to an assembly compilation</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.PublicKey">
            <summary>Public key or token</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.Name">
            <summary>Assembly name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.Locale">
            <summary>Assembly locale</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRow.Version">
            <summary>Assembly version</summary>
        </member>
        <member name="M:AlphaOmega.Debug.MemoryLoader.#ctor(System.String)">
            <summary>Create instance of PE/PE+ loader from memory</summary>
            <param name="filePath">Path to the file to load</param>
            <exception cref="T:ArgumentNullException">filePath is empty</exception>
            <exception cref="T:FileNotFoundException">File filePath not found</exception>
        </member>
        <member name="M:AlphaOmega.Debug.MemoryLoader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Read array of bytes from memory</summary>
            <param name="padding">Padding from starting value</param>
            <param name="length">Length to read from padding</param>
            <exception cref="T:NotImplementedException">ReadBytes method is not implemented</exception>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.MemoryLoader.PtrToStructure``1(System.UInt32)">
            <summary>Get structure from specific padding from the beginning of the image</summary>
            <typeparam name="T">Structure type</typeparam>
            <param name="padding">Padding from the beginning of the image</param>
            <exception cref="T:NotImplementedException">PtrToStructure method is not implemented</exception>
            <returns>Readed structure from image</returns>
        </member>
        <member name="M:AlphaOmega.Debug.MemoryLoader.PtrToStringAnsi(System.UInt32)">
            <summary>Get ACSII string from specific padding from the beginning of the image</summary>
            <param name="padding">Padding from the beginning of the image</param>
            <exception cref="T:ArgumentOutOfRangeException">padding more than size of image</exception>
            <exception cref="T:NotImplementedException">PtrToStringAnsi method is not implemented</exception>
            <returns>String from pointer</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.GuidHeap">
            <summary>Guid heap class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.GuidHeap.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of Guid heap class</summary>
            <param name="meta">MetaData directory</param>
            <param name="header">.NET stream header</param>
            <exception cref="T:InvalidOperationException">GuidHeap can only read Guid heaps</exception>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.GuidHeap.Item(System.Int32)">
            <summary>Получить Guid по сдвигу.</summary>
            <param name="index">Сдвиг с начала кучи.</param>
            <returns>Guid по сдвигу.</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.GuidHeap.Data">
            <summary>heap data</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceManifest">
            <summary>Xml resource Manifest reader class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceManifest.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of manifest resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceManifest.GetXmlStream">
            <summary>Получить поток для передачи в <see cref="T:System.Data.DataSet"/></summary>
            <remarks>Получаемый поток необходимо отпустить после выполнения действий</remarks>
            <returns>Поток для загрузки в DataSet</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceManifest.Xml">
            <summary>Manifest xml</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.DebugPdb2">
            <summary>CodeView PDB v2 class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.DebugPdb2.Info">
            <summary>PDB v2 Info</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.DebugPdb2.PdbFileName">
            <summary>Null-terminated name of the PDB file. It can also contain full or partial path to the file.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.DebugPdb2.#ctor(AlphaOmega.Debug.WinNT.Debug.CV_INFO_PDB20,System.String)">
            <summary>Create instance of CodeView PDB v2 class</summary>
            <param name="info">CodeView v2 Info</param>
            <param name="pdbFileName">PDB file name saved in PE file</param>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaRowCollection">
            <summary>MetaTable rows collection</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaRowCollection.#ctor(AlphaOmega.Debug.CorDirectory.Meta.MetaTable)">
            <summary>Create instance of rows collection class</summary>
            <param name="table">Table from whitch taken all rows</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaRowCollection.GetEnumerator">
            <summary>Get all rows from table</summary>
            <returns>Rows collection</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventPtrRow">
            <summary>An event map-to-events lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventPtrRow.Event">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ENCMapRow">
            <summary>
            Edit-and-continue mapping descriptors.
            This table does not exist in optimized metadata (#~ stream).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ENCMapRow.Token">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.BlobHeap">
            <summary>BLOB heap class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.BlobHeap.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of BLOB heap class</summary>
            <param name="meta">MetaData directory</param>
            <param name="header">.NET stream header</param>
            <exception cref="T:InvalidOperationException">Blob heap can read only UnicodeString and Blob heaps</exception>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.BlobHeap.Item(System.Int32)">
            <summary>Get byte array from BLOB heap</summary>
            <param name="index">BLOB index in the heap</param>
            <returns>byte array by index from heap</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.BlobHeap.Data">
            <summary>All BLOB data from heap</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MetaTable">
            <summary>MetaTable class</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaTable._rowSize">
            <summary>Размер ряда с данными</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.MetaTable._padding">
            <summary>Отступ от начала блока с таблицами</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.#ctor(AlphaOmega.Debug.CorDirectory.Meta.StreamTables,AlphaOmega.Debug.Cor.MetaTableType,System.UInt32)">
            <summary>Создание экземпляра класса мета-таблицы</summary>
            <param name="root">Корневой поток</param>
            <param name="tableType">Тип таблицы</param>
            <param name="padding">Отступ от начала потома метаданных</param>
            <exception cref="T:ArgumentNullException">root is null</exception>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.SizeOfColumns">
            <summary>Получить размер всех колонок в таблице</summary>
            <returns>Размер ряда в таблице</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.SizeOfColumn(AlphaOmega.Debug.CorDirectory.Meta.MetaColumnType)">
            <summary>Получить размер колонки в таблице</summary>
            <param name="type">Тип колонки</param>
            <returns>Размер колонки</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.GetTableDescription(AlphaOmega.Debug.Cor.MetaTableType)">
            <summary>Получить описатель таблицы</summary>
            <param name="table">Таблица для получения колонок</param>
            <exception cref="T:NotSupportedException">Unknown table</exception>
            <exception cref="T:InvalidOperationException">Column names not equal column types</exception>
            <returns>Массив колонок в таблице</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.Columns">
            <summary>Массив колонок в таблице</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.RowsI">
            <summary>Массив рядов в таблице</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.RowsCount">
            <summary>Кол-во рядов в таблице</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.Data">
            <summary>Массив данных в таблице</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.RowSize">
            <summary>Размер ряда</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.TableType">
            <summary>Тип таблицы</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.TableSize">
            <summary>Размер всей таблицы с данными</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.Rows">
            <summary>Rows in table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MetaTable.Item(System.UInt32)">
            <summary>Получить ряд из таблицы</summary>
            <param name="rowIndex">Индекс ряда в таблице</param>
            <exception cref="T:ArgumentOutOfRangeException">rowIndex out of range of table rows</exception>
            <returns>Ряд с данными</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.StandAloneSigRow">
            <summary>
            Signatures are stored in the metadata Blob heap.
            In most cases, they are indexed by a column in some table —
            Field.Signature, Method.Signature, MemberRef.Signature, etc.
            However, there are two cases that require a metadata token for a signature
            that is not indexed by any metadata table.
            The StandAloneSig table fulfils this need.
            It has just one column, which points to a Signature in the Blob heap.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.StandAloneSigRow.Signature">
            <summary>
            The signature shall describe either:
            	A method – code generators create a row in the StandAloneSig table for each occurrence of a calli CIL instruction. That row indexes the call-site signature for the function pointer operand of the calli instruction.
            	Local variables – code generators create one row in the StandAloneSig table for each method, to describe all of its local variables. The .locals directive (§II.15.4.1) in ILAsm generates a row in the StandAloneSig table.
            </summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyPtrRow">
            <summary>A property map-to-properties lookup table, whitch does not exists on optimized metadata (#~ stream).</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.PropertyPtrRow.Property">
            <summary>Banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamRow">
            <summary>
            The rows in the Param table result from the parameters in a method declaration (§II.15.4),
            or from a .param attribute attached to a method (§II.15.4.1).
            </summary>
            <remarks>Conceptually, every row in the Param table is owned by one, and only one, row in the MethodDef table.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamRow.Flags">
            <summary>Flags that can be associated with parameter.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamRow.Sequence">
            <summary>Parameter index in method definition.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamRow.Name">
            <summary>Parameter name</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow">
            <summary>Module descriptor.</summary>
            <remarks>
            The Generation, EncId, and EncBaseId columns can be written as zero,
            and can be ignored by conforming implementations of the CLI.
            The rows in the Module table result from .module directives in the Assembly (§II.6.4).
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow.Generation">
            <summary>A 2-byte value, reserved, shall be zero</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow.Name">
            <summary>Module name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow.Mvid">
            <summary>
            The Mvid column shall index a unique GUID in the GUID heap (§II.24.2.5)
            that identifies this instance of the module.
            The Mvid can be ignored on read by conforming implementations of the CLI.
            The Mvid should be newly generated for every module, using the algorithm specified in
            ISO/IEC 11578:1996 (Annex A) or another compatible algorithm.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow.EncId">
            <summary>An index into the Guid heap; reserved, shall be zero.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ModuleRow.EncBaseId">
            <summary>An index into the Guid heap; reserved, shall be zero.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamConstraintRow">
            <summary>
            The GenericParamConstraint table records the constraints for each generic parameter.
            Each generic parameter can be constrained to derive from zero or one class.
            Each generic parameter can be constrained to implement zero or more interfaces.
            </summary>
            <remarks>Conceptually, each row in the GenericParamConstraint table is "owned" by a row in the GenericParam table.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamConstraintRow.OwnerI">
            <summary>An index into the GenericParam table, specifying to which generic parameter this row refers.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamConstraintRow.Constraint">
            <summary>
            An index into the TypeDef, TypeRef, or TypeSpec tables,
            specifying from which class this generic parameter is constrained to derive;
            or which interface this generic parameter is constrained to implement;
            more precisely, a TypeDefOrRef (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.GenericParamConstraintRow.Owner">
            <summary>GenericParam table row</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.DeclSecurityRow">
            <summary>
            Security attributes, which derive from System.Security.Permissions.SecurityAttribute (see Partition IV),
            can be attached to a TypeDef, a Method, or an Assembly.
            All constructors of this class shall take a System.Security.Permissions.SecurityAction value
            as their first parameter, describing what should be done with the permission on the type,
            method or assembly to which it is attached.
            Code access security attributes, which derive from System.Security.Permissions.
            CodeAccessSecurityAttribute, can have any of the security actions.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.DeclSecurityRow.Action">
            <summary>
            Action is a 2-byte representation of Security Actions (see System.Security.SecurityAction in Partition IV).
            The values 0 – 0xFF are reserved for future standards use.
            Values 0x20 – 0x7F and 0x100 – 0x07FF are for uses where the action can be ignored if it is not understood or supported.
            Values 0x80 – 0xFF and 0x0800 – 0xFFFF are for uses where the action shall be implemented for secure operation;
            in implementations where the action is not available, no access to the assembly, type, or method shall be permitted.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.DeclSecurityRow.Parent">
            <summary>
            an index into the TypeDef, MethodDef, or Assembly table;
            more precisely, a HasDeclSecurity (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.DeclSecurityRow.PermissionSet">
            <summary>
            The permission set contains the permissions that were requested with an
            Action on a specific Method, Type, or Assembly (see Parent).
            In other words, the blob will contain an encoding of all the attributes on the Parent
            with that particular Action.
            </summary>
            <remarks>
            PermissionSet is a 'blob' having the following format:
                A byte containing a period (.).
                A compressed unsigned integer containing the number of attributes encoded in the blob.
                An array of attributes each containing the following:
                    A String, which is the fully-qualified type name of the attribute. (Strings are encoded as a compressed unsigned integer to indicate the size followed by an array of UTF8 characters.)
                    A set of properties, encoded as the named arguments to a custom attribute would be (as in §II.23.3, beginning with NumNamed).
            </remarks>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.MethodBody">
            <summary>Method body descriptor</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MethodBody.GetOpCodes(System.Byte[])">
            <summary>Returns the OpCodes represented by a MSIL byte array.</summary>
            <param name="data">MSIL byte array.</param>
            <returns>An array of the OpCodes representing the MSIL code.</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MethodBody.GetMethodBody">
            <summary>Получить тело метода</summary>
            <returns>Массив байт описывающий CIL</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MethodBody.GetMethodBody2">
            <summary>Get method body as MSIL instructions array</summary>
            <returns>MSIL instructions array</returns>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.MethodBody.GetSections">
            <summary>Get fat method header sections</summary>
            <returns>Method header sections</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.MethodBody.Header">
            <summary>Method header</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ComDescriptor">
            <summary>.NET directory class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ComDescriptor.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of .NET directory</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.Cor20Header">
            <summary>Заголовок .NET приложения</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.MetaData">
            <summary>Мета данные</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.VTable">
            <summary>VTable directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.StrongNameSignature">
            <summary>Strong name signature directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.CodeManagerTable">
            <summary>Code manager table directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.Eat">
            <summary>Export Address table jumps directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.ManagedNativeHeaer">
            <summary>Managed header</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ComDescriptor.Resources">
            <summary>Managed resources</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CorSignature">
            <summary>Fields, properties and other members signatures</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.DEFAULT">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.C">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.STDCALL">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.THISCALL">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.FASTCALL">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.VARARG">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.FIELD">
            <summary>Field signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.LOCAL_SIG">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.PROPERTY">
            <summary>Property signature</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.HASTHIS">
            <summary>Instance member</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.EXPLICITTHIS">
            <summary>banana</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorSignature.SENTINEL">
            <summary>banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow">
            <summary>Class in the current assembly.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.ToString">
            <summary>TypeNamespace+"."+TypeName</summary>
            <returns>String</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.Flags">
            <summary>A 4-byte bit mask of type TypeAttributes (#II.23.1.15) .</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.TypeName">
            <summary>Type name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.TypeNamespace">
            <summary>Type namespace</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.Extends">
            <summary>an index into the TypeDef, TypeRef, or TypeSpec table; more precisely, a TypeDefOrRef (#II.24.2.6) coded index</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.FieldListI">
            <summary>An index into the Field table; it marks the first of a contiguous run of Fields owned by this Type.</summary>
            <remarks>
            The run continues to the smaller of:
            The last row of the Field table.
            The next run of Fields, found by inspecting the FieldList of the next row in this TypeDef table.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.MethodListI">
            <summary>An index into the MethodDef table; it marks the first of a continguous run of Methods owned by this Type.</summary>
            <remarks>
            The run continues to the smaller of:
            The last row of the MethodDef table.
            the next run of Methods, found by inspecting the MethodList of the next row in this TypeDef table.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.FieldList">
            <summary>Fields rows</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeDefRow.MethodList">
            <summary>Methods rows</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.InterfaceImplRow">
            <summary>The InterfaceImpl table records the interfaces a type implements explicitly.</summary>
            <remarks>Conceptually, each row in the InterfaceImpl table indicates that Class implements Interface.</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.InterfaceImplRow.ClassI">
            <summary>Index into the TypeDef table.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.InterfaceImplRow.Interface">
            <summary>
            An index into the TypeDef, TypeRef, or TypeSpec table;
            more precisely, a TypeDefOrRef (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.InterfaceImplRow.Class">
            <summary>TypeDef table row that implements current interface.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Eat">
            <summary>Export Address table jumps class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Eat.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of EAT class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Resource">
            <summary>Native resource directory class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetVersion">
            <summary>Получить информацию о версии PE файла из ресурсов</summary>
            <returns>Информация о версии PE файла</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetManifest">
            <summary>Получить манифест из ресурсов PE файла</summary>
            <returns>Манифест</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetStrings">
            <summary>Получить все строки из ресурсов</summary>
            <returns>Строки из PE файла</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetAccelerators">
            <summary>Получить все акселераторы из ресурсов</summary>
            <returns>Акселераторы</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetMessageTables">
            <summary>Get message tables resource classes</summary>
            <returns>Message Table classes</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetDialogs">
            <summary>Получить описание ококн в приложении</summary>
            <returns>Список диалогов в приложении</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetMenus">
            <summary>Получить описание меню в приложении</summary>
            <returns>Список меню в приложении</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetBitmaps">
            <summary>Получить описание всех картинок в ресурсах</summary>
            <returns>Список всех картинок в ресурсах</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetFontDirs">
            <summary>Получить описание всех директорий ресурсов</summary>
            <returns>Список всех директорий с ресурсами</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetFonts">
            <summary>Получить шрифты из ресурсов</summary>
            <returns>Список всех шрифтов из ресурсов</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetResources(AlphaOmega.Debug.WinNT.Resource.RESOURCE_DIRECTORY_TYPE)">
            <summary>Получить директории с данными</summary>
            <param name="directoryType">Тип директроии ресурсы из которой получить</param>
            <returns>Директории соответствующий определённой директории</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of resource directory class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Resource.GetEnumerator">
            <summary>Get recource directories from image direstory</summary>
            <returns>Resourec directories</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Resource.RootResource">
            <summary>Root resource directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Export">
            <summary>Export directory class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Export.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of Export class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Export.GetExportFunctions">
            <summary>Получить список экспортируемых функций</summary>
            <returns>Массив с адресами экспортируемых функций</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Export.IsEmpty">
            <summary>Directory is empty</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Export.ExportDirectory">
            <summary>Директория экспортируемых функций</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.Export.DllName">
            <summary>Module name</summary>
        </member>
        <member name="T:AlphaOmega.Debug.PEHeader">
            <summary>PE/PE+ Header</summary>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.#ctor(AlphaOmega.Debug.IImageLoader)">
            <summary>Create instance of PE header reader</summary>
            <param name="loader">Image loader</param>
            <exception cref="T:ArgumentNullException">loader is null</exception>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.ValidatePeFile">
            <summary>Validata PE headers</summary>
            <exception cref="T:InvalidOperationException">PE image is invalid</exception>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.OffsetToRva(System.UInt32)">
            <summary>Convert relative address to virtual address</summary>
            <param name="offset">RVA in PE image</param>
            <returns>VA in image</returns>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Read bytes from image</summary>
            <param name="offset">RVA to start address</param>
            <param name="length">How mutch to read</param>
            <returns>Readed bytes</returns>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.PtrToStructure``1(System.UInt32)">
            <summary>Get structure from specific RVA</summary>
            <typeparam name="T">Structure to map</typeparam>
            <param name="offset">RVA to the beggining of structure</param>
            <returns>Mapped structure</returns>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.PtrToStringAnsi(System.UInt32)">
            <summary>Get string from specific RVA</summary>
            <param name="offset">RVA to the beggining of string</param>
            <returns>Mapped string</returns>
        </member>
        <member name="M:AlphaOmega.Debug.PEHeader.Dispose">
            <summary>Close header and loader</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.Loader">
            <summary>PE/PE+ loader interface</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.HeaderDos">
            <summary>DOS заголовок PE файла.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.Is64Bit">
            <summary>Загружаемый PE файл является PE+.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.IsValidHeader">
            <summary>Загруженный PE файл является валидным</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.HeaderNT32">
            <summary>PE Header</summary>
            <exception cref="T:InvalidOperationException">Invalid DOS header</exception>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.HeaderNT64">
            <summary>PE+ Header</summary>
            <exception cref="T:InvalidOperationException">Invalid DOS header</exception>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.SymbolTable">
            <summary>Represents the COFF symbols header.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.Sections">
            <summary>PE sections</summary>
        </member>
        <member name="P:AlphaOmega.Debug.PEHeader.ImageSize">
            <summary>Entry size of a PE image</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Relocation">
            <summary>Relocation table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Relocation.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of Relocation table class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Relocation.GetEnumerator">
            <summary>Get all relocations blocks from directory</summary>
            <returns>Relocation blocks</returns>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.Architecture">
            <summary>Architecture class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.Architecture.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of Architecture class</summary>
            <param name="root">Data directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSpecRow">
            <summary>Generic method instantiation descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSpecRow.Method">
            <summary>
            An index into the MethodDef or MemberRef table, specifying to which generic method this row refers;
            that is, which generic method this row is an instantiation of;
            more precisely, a MethodDefOrRef (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodSpecRow.Instantiation">
            <summary>Signature of this instantiation</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodImplRow">
            <summary>
            MethodImpl tables let a compiler override the default inheritance rules provided by the CLI.
            Their original use was to allow a class C, that inherited method M from both interfaces I and J, to provide implementations for both methods (rather than have only one slot for M in its vtable).
            However, MethodImpls can be used for other reasons too, limited only by the compiler writer’s ingenuity within the constraints defined in the Validation rules below.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodImplRow.ClassI">
            <summary>An index into the TypeDef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodImplRow.MethodBody">
            <summary>An index into the MethodDef or MemberRef table; more precisely, a MethodDefOrRef (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodImplRow.MethodDeclaration">
            <summary>An index into the MethodDef or MemberRef table; more precisely, a MethodDefOrRef (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodImplRow.Class">
            <summary>TypeDef table row</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1">
            <summary>Базовый класс для детализированного описания таблицы в метаданных</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1.#ctor(AlphaOmega.Debug.CorDirectory.Meta.StreamTables,AlphaOmega.Debug.Cor.MetaTableType)">
            <summary>Создание экземпляра базового класса детализированного описания таблицы в метаданных</summary>
            <param name="stream">Поток</param>
            <param name="type">Тип таблицы</param>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1.GetEnumerator">
            <summary>Получить в итерации список всех рядов в таблице метаданных</summary>
            <returns>Ряд метаданных детально описывающий структуру таблицы</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1.Table">
            <summary>Таблица в метаданных</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1.TableType">
            <summary>Тип таблицы из метаданных</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.BaseMetaTable`1.Item(System.UInt32)">
            <summary>Получить детализированный ряд из таблицы метаданных</summary>
            <param name="rowIndex">Индекс ряда из таблицы</param>
            <returns>Детализированный ряд таблицы из метаданных</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldMarshalRow">
            <summary>
            The FieldMarshal table has two columns.
            It "links" an existing row in the Field or Param table,
            to information in the Blob heap that defines how that field or parameter
            (which, as usual, covers the method return, as parameter number 0)
            shall be marshalled when calling to or from unmanaged code via PInvoke dispatch.
            </summary>
            <remarks>
            Note that FieldMarshal information is used only by code paths that arbitrate operation with unmanaged code.
            In order to execute such paths, the caller, on most platforms,
            would be installed with elevated security permission.
            Once it invokes unmanaged code, it lies outside the regime that the CLI can check — it is simply trusted not to violate the type system.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldMarshalRow.Parent">
            <summary>An index into Field or Param table; more precisely, a HasFieldMarshal (§II.24.2.6) coded index.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldMarshalRow.Native">
            <summary>An index into the Blob heap</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow">
            <summary>The table is defined by the .assembly extern directive</summary>
            <remarks>
            Its columns are filled using directives similar to those of the Assembly table
            except for the PublicKeyOrToken column, which is defined using the .publickeytoken directive.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.MajorVersion">
            <summary>Major assembly version</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.MinorVersion">
            <summary>Minor assembly version</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.BuildNumber">
            <summary>Build number</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.RevisionNumber">
            <summary>Revision number</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.Flags">
            <summary>Assembly flags</summary>
            <remarks>Flags shall have only one bit set, the PublicKey bit (§II.23.1.2). All other bits shall be zero</remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.PublicKeyOrToken">
            <summary>an index into the Blob heap, indicating the public key or token that identifies the author of this Assembly</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.Name">
            <summary>Assembly name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.Locale">
            <summary>Culture</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.HashValue">
            <summary>an index into the Blob heap</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefRow.Version">
            <summary>Full assembly version</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.ManagedNativeHeaer">
            <summary>.NET Managed native header class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.ManagedNativeHeaer.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of Managed native header class</summary>
            <param name="parent">.NET directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.BoundImportReference">
            <summary>Forwarded DLL reference</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.BoundImportReference.FfwdRef">
            <summary>Reference</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.BoundImportReference.ModuleName">
            <summary>Module name</summary>
        </member>
        <member name="T:AlphaOmega.Debug.BytesReader">
            <summary>Reader from memory allocated bytes array</summary>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.#ctor(System.Byte[])">
            <summary>Create instance of bytesreader class</summary>
            <param name="bytes">Bytes</param>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.UInt32@)">
            <summary>Накладывание структуры на массив байт и увеличивание отступа на размер массива</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="padding">Отступ от начала массива байт и отступ от начала массива + конца структуры</param>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.UInt32)">
            <summary>Накладывание структуры на массив байт</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="padding">Отступ от начала массива байт</param>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.UInt32,System.Int32@)">
            <summary>Накладывание структуры на массив байт</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="padding">Отступ от начала массива байт</param>
            <param name="length">Размер полчившегося массива</param>
            <exception cref="T:ArgumentOutOfRangeException">padding+structure size is out of range of byte array</exception>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringUni(System.UInt32)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Отступ от начала массива</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringUni(System.UInt32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Отступ от начала массива, который после возврата станет отступом от конца строки</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringUni(System.UInt32,System.Int32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Отступ от начала массива</param>
            <param name="length">Результатирующий размер строки</param>
            <exception cref="T:ArgumentOutOfRangeException">Bytes array is smaller than padding</exception>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringAnsi(System.UInt32)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Отступ от начала массива</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringAnsi(System.UInt32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Отступ от начала массива, который после возврата станет отступом от конца строки</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringAnsi(System.UInt32,System.Int32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="padding">Offset from the beginning of the array</param>
            <param name="length">Результатирующий размер строки</param>
            <exception cref="T:ArgumentOutOfRangeException">Bytes array is smaller than padding</exception>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.GetBytes(System.UInt32,System.UInt32)">
            <summary>Get bytes from data</summary>
            <param name="padding">Offset from the beginning of the array</param>
            <param name="length">Length</param>
            <exception cref="T:ArgumentOutOfRangeException">index>Index and length is larger than bytes array length</exception>
            <returns>Bytes from index</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.Byte[],System.UInt32@)">
            <summary>Накладывание структуры на массив байт и увеличивание отступа на размер массива</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="bytes">Массив байт на который наложить структуру</param>
            <param name="padding">Отступ от начала массива байт и отступ от начала массива + конца структуры</param>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.Byte[],System.UInt32)">
            <summary>Накладывание структуры на массив байт</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="bytes">Массив байт на который наложить структуру</param>
            <param name="padding">Отступ от начала массива байт</param>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStructure``1(System.Byte[],System.UInt32,System.Int32@)">
            <summary>Накладывание структуры на массив байт</summary>
            <typeparam name="T">Тип накладываемой структуры</typeparam>
            <param name="bytes">Массив байт на который наложить структуру</param>
            <param name="padding">Отступ от начала массива байт</param>
            <param name="length">Размер полчившегося массива</param>
            <returns>Наложенная структура с данными</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringUni(System.Byte[],System.UInt32,System.Int32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="bytes">Массив байт</param>
            <param name="padding">Отступ от начала массива</param>
            <param name="length">Результатирующий размер строки</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.BytesToStringAnsi(System.Byte[],System.UInt32,System.Int32@)">
            <summary>Преобразование массива байт от отступа в строку</summary>
            <param name="bytes">Массив байт</param>
            <param name="padding">Отступ от начала массива</param>
            <param name="length">Результатирующий размер строки</param>
            <returns>Получаемая строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.StructureToArray``1(``0)">
            <summary>Преобразование структуры из памяти в массив байт</summary>
            <typeparam name="T">Структура, которую необходимо преобразовать</typeparam>
            <param name="structure">Структура для преобразования</param>
            <returns>Массив байт</returns>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.Dispose">
            <summary>Release allocated memory</summary>
        </member>
        <member name="M:AlphaOmega.Debug.BytesReader.Dispose(System.Boolean)">
            <summary>Release allocated memory</summary>
            <param name="disposing">Free managed resources</param>
        </member>
        <member name="P:AlphaOmega.Debug.BytesReader.Bytes">
            <summary>Bytes array</summary>
        </member>
        <member name="P:AlphaOmega.Debug.BytesReader.Handle">
            <summary>Allocated handle</summary>
        </member>
        <member name="P:AlphaOmega.Debug.BytesReader.Item(System.UInt32)">
            <summary>Read byte from index</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:AlphaOmega.Debug.BytesReader.Length">
            <summary>Length of the array</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap">
            <summary>Specifies options for a PInvoke call.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms233461.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmNoMangle">
            <summary>Use each member name as specified.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCharSetMask">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCharSetNotSpec">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCharSetAnsi">
            <summary>Marshal strings as multiple-byte character strings.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCharSetUnicode">
            <summary>Marshal strings as Unicode 2-byte characters.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCharSetAuto">
            <summary>
            Automatically marshal strings appropriately for the target operating system.
            The default is Unicode on Windows NT, Windows 2000, Windows XP, and the Windows Server 2003 family;
            the default is ANSI on Windows 98 and Windows Me.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmBestFitUseAssem">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmBestFitEnabled">
            <summary>Perform best-fit mapping of Unicode characters that lack an exact match in the ANSI character set.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmBestFitDisabled">
            <summary>Do not perform best-fit mapping of Unicode characters. In this case, all unmappable characters will be replaced by a ‘?’.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmBestFitMask">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmThrowOnUnmappableCharUseAssem">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmThrowOnUnmappableCharEnabled">
            <summary>Throw an exception when the interop marshaler encounters an unmappable character.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmThrowOnUnmappableCharDisabled">
            <summary>Do not throw an exception when the interop marshaler encounters an unmappable character.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmThrowOnUnmappableCharMask">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmSupportsLastError">
            <summary>Allow the callee to call the Win32 SetLastError function before returning from the attributed method.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvMask">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvWinapi">
            <summary>
            Use the default platform calling convention.
            For example, on Windows the default is StdCall and on Windows CE .NET it is Cdecl.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvCdecl">
            <summary>
            Use the Cdecl calling convention.
            In this case, the caller cleans the stack.
            This enables calling functions with varargs (that is, functions that accept a variable number of parameters).
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvStdcall">
            <summary>
            Use the StdCall calling convention.
            In this case, the callee cleans the stack.
            This is the default convention for calling unmanaged functions with platform invoke.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvThiscall">
            <summary>
            Use the ThisCall calling convention.
            In this case, the first parameter is the this pointer and is stored in register ECX.
            Other parameters are pushed on the stack.
            The ThisCall calling convention is used to call methods on classes exported from an unmanaged DLL.
            </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmCallConvFastcall">
            <summary>Reserved.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorPinvokeMap.pmMaxValue">
            <summary>Reserved.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow">
            <summary>Method definition descriptors.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.RVA">
            <summary>Method body address</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.ImplFlags">
            <summary>Specifies flags for the attributes of a method implementation.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.Flags">
            <summary>Specifies flags for method attributes. These flags are defined in the corhdr.h file.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.Name">
            <summary>Method name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.Signature">
            <summary>
            As name implies, this signature stores information related to methods defined in current assembly,
            such as the calling convention type, the number of generic parameters,
            the number of normal method's parameters,
            the return type and the type of each parameter supplied to the method.
            Is indexed by the MethodDef.Signature column.
            </summary>
            <remarks>If Signature is GENERIC (0x10), the generic arguments are described in the GenericParam table (§II.22.20). </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.ParamListI">
            <summary>Index into the Param table.</summary>
            <remarks>
            It marks the first of a contiguous run of Parameters owned by this method. The run continues to the smaller of:
            The last row of the Param table.
            The next run of Parameters, found by inspecting the ParamList of the next row in the MethodDef table.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.ParamList">
            <summary>Получить список параметров для метода.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.MethodDefRow.Body">
            <summary>Method body descriptor</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow">
            <summary>The ImplMap table holds information about unmanaged methods that can be reached from managed code, using PInvoke dispatch.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow.MappingFlags">
            <summary>a 2-byte bitmask of type PInvokeAttributes, §23.1.8</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow.MemberForwarded">
            <summary>
            an index into the Field or MethodDef table; more precisely,
            a MemberForwarded (§II.24.2.6) coded index).
            However, it only ever indexes the MethodDef table, since Field export is not supported.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow.ImportName">
            <summary>Unmanaged method name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow.ImportScopeI">
            <summary>an index into the ModuleRef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ImplMapRow.ImportScope">
            <summary>Umanaged library name</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRVARow">
            <summary>Field-to-data mapping descriptors</summary>
            <remarks>
            Conceptually, each row in the FieldRVA table is an extension to exactly one row in the Field table,
            and records the RVA (Relative Virtual Address)
            within the image file at which this field’s initial value is stored.
            
            A row in the FieldRVA table is created for each static parent field
            that has specified the optional data label §II.16).
            The RVA column is the relative virtual address of the data in the PE file (§II.16.3).
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRVARow.RVA">
            <summary>a 4-byte constant</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRVARow.FieldI">
            <summary>An index into Field table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.FieldRVARow.Field">
            <summary>Row from Field table</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags">
            <summary>Contains values that describe the metadata applied to an assembly compilation.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms232517.aspx</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPublicKey">
            <summary>Indicates that the assembly reference holds the full, unhashed public key. </summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_None">
            <summary>Indicates that the processor architecture is unspecified.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_MSIL">
            <summary>Indicates that the processor architecture is neutral (PE32).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_x86">
            <summary>Indicates that the processor architecture is x86 (PE32).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_IA64">
            <summary>Indicates that the processor architecture is Itanium (PE32+).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_AMD64">
            <summary>Indicates that the processor architecture is AMD X64 (PE32+).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_ARM">
            <summary>Indicates that the processor architecture is ARM (PE32).</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_NoPlatform">
            <summary>Indicates that the assembly is a reference assembly; that is, it applies to any architecture but cannot run on any architecture.</summary>
            <remarks>Thus, the flag is the same as afPA_Mask.</remarks>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_Specified">
            <summary>Indicates that the processor architecture flags should be propagated to the AssemblyRef record.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_Mask">
            <summary>A mask that describes the processor architecture.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_FullMask">
            <summary>Specifies that the processor architecture description is included.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afPA_Shift">
            <summary>Indicates a shift count in the processor architecture flags to and from the index.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afEnableJITcompileTracking">
            <summary>Indicates the corresponding value from the <see cref="T:System.Diagnostics.DebuggableAttribute.DebuggingModes"/> of the <see cref="T:System.Diagnostics.DebuggableAttribute"/>.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afDisableJITcompileOptimizer">
            <summary>Indicates the corresponding value from the <see cref="T:System.Diagnostics.DebuggableAttribute.DebuggingModes"/> of the <see cref="T:System.Diagnostics.DebuggableAttribute"/>.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afRetargetable">
            <summary>Indicates that the assembly can be retargeted at run time to an assembly from a different publisher.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afContentType_Default">
            <summary>Indicates the default content type.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afContentType_WindowsRuntime">
            <summary>Indicates the Windows Runtime content type.</summary>
        </member>
        <member name="F:AlphaOmega.Debug.CorDirectory.Meta.CorAssemblyFlags.afContentType_Mask">
            <summary>A mask that describes the content type.</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeRefRow">
            <summary>Class reference descriptors</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeRefRow.ResolutionScope">
            <summary>
            an index into a Module, ModuleRef, AssemblyRef or TypeRef table, or null;
            more precisely, a ResolutionScope (§II.24.2.6) coded index.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeRefRow.TypeName">
            <summary>Type name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.TypeRefRow.TypeNamespace">
            <summary>Type namespace</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamPtrRow">
            <summary>A method-to-parameters lookup table, whitch does not exists on optimized metadata</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ParamPtrRow.Param">
            <summary>banana banana banana</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.NestedClassRow">
            <summary>NestedClass is defined as lexically "inside" the text of its enclosing Type.</summary>
            <remarks>
            The NestedClass table records which Type definitions are nested within which other Type definition.
            In a typical high-level language, the nested class is defined as lexically "inside" the text of its enclosing Type
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.NestedClassRow.NestedClassI">
            <summary>An index into the TypeDef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.NestedClassRow.EnclosingClassI">
            <summary>An index into the TypeDef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.NestedClassRow.NestedClass">
            <summary>Child class row from TypeDef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.NestedClassRow.EnclosingClass">
            <summary>Parent class row from TypeDef table</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow">
            <summary>Internal or external resource</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.GetResourceReader">
            <summary>Create instance of resource reader class pointed to resource file on current PE file</summary>
            <returns>Contexts of resource file</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.OffsetI">
            <summary>The Offset specifies the byte offset within the referenced file at which this resource record begins.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.Offset">
            <summary>The Offset specifies the byte offset within the referenced file at which this resource record begins and size of resource file is skipped.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.Flags">
            <summary>Resource flags.</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.Name">
            <summary>Manifest resource name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.Implementation">
            <summary>The Implementation specifies which file holds this resource.</summary>
            <remarks>
            An index into a File table, a AssemblyRef table, or null;
            more precisely, an Implementation (§II.24.2.6) coded index.
            </remarks>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.Size">
            <summary>Size of file in the resource directory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.File">
            <summary>File contents from managed Resource directory</summary>
            <exception cref="T:System.NotImplementedException">Implementation points to row</exception>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.FileInDirectory">
            <summary>Файл находится в директории с управляемыми ресурсами</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.ManifestResourceRow.ResourceDirectory">
            <summary>Managed resource directory</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefProcessorRow">
            <summary>
            These records should not be emitted into any PE file.
            However, if present in a PE file, they should be treated as-if their fields were zero.
            They should be ignored by the CLI.
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefProcessorRow.Processor">
            <summary>a 4-byte constant</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefProcessorRow.AssemblyRefI">
            <summary>an index into the AssemblyRef table</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.AssemblyRefProcessorRow.AssemblyRef">
            <summary>Pointer into the AssemblyRef table</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.CodeManagerTable">
            <summary>.NET Code Manager table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.CodeManagerTable.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of Code Manger table class</summary>
            <param name="parent">.NET directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.Win32Loader">
            <summary>HMODULE loader class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.FromFile(System.String)">
            <summary>Load image from file</summary>
            <param name="filePath">Path to file</param>
            <exception cref="T:ArgumentNullException">filePath is null</exception>
            <exception cref="T:FileNotFoundException">File on path filePath not found</exception>
            <exception cref="T:Win32Exception">LoadLibrary can't load PE/PE+ image</exception>
            <returns>Loader</returns>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.FromModule(System.Diagnostics.ProcessModule)">
            <summary>Load image from HModule</summary>
            <param name="module">Loaded module</param>
            <exception cref="T:ArgumentNullException">module is null</exception>
            <returns>Loader</returns>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.#ctor(System.IntPtr)">
            <summary>Create instance of HMODULE loader class</summary>
            <param name="hModule">HMODULE</param>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.#ctor(System.IntPtr,System.String,System.Boolean)">
            <summary>Create instance of HMODULE loader class</summary>
            <param name="hModule">HMODULE</param>
            <param name="source">Source of file</param>
            <param name="freeOnClode">Close HMODULE after exit</param>
            <exception cref="T:ArgumentNullException">hModule is empty</exception>
            <exception cref="T:ArgumentNullException">source is null</exception>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.ReadBytes(System.UInt32,System.UInt32)">
            <summary>Получить массив байт с начала отступа</summary>
            <param name="padding">Отступ от начала файла или RVA</param>
            <param name="length">Читаемый размер</param>
            <returns>Получить массив байт с отступа</returns>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.PtrToStructure``1(System.UInt32)">
            <summary>Получить структуру с определённого отступа</summary>
            <typeparam name="T">Структура</typeparam>
            <param name="padding">Отступ от начала файла или RVA</param>
            <returns>Прочитанная структура</returns>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.PtrToStringAnsi(System.UInt32)">
            <summary>Получить строку с отпределённого отступа</summary>
            <param name="padding">Отступ от начала файла или RVA</param>
            <returns>Прочитанная строка</returns>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.Dispose">
            <summary>Free HMODULE</summary>
            <exception cref="T:Win32Exception">Can't unload library</exception>
        </member>
        <member name="M:AlphaOmega.Debug.Win32Loader.Dispose(System.Boolean)">
            <summary>Dispose managed objects</summary>
            <param name="disposing">Dispose managed objects</param>
        </member>
        <member name="P:AlphaOmega.Debug.Win32Loader.IsModuleMapped">
            <summary>Module mapped to memory</summary>
        </member>
        <member name="P:AlphaOmega.Debug.Win32Loader.BaseAddress">
            <summary>Базовый адрес загруженного модуля</summary>
            <exception cref="T:System.ObjectDisposedException">Object disposed</exception>
        </member>
        <member name="P:AlphaOmega.Debug.Win32Loader.Source">
            <summary>Источник получения PE модуля</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.LoadConfig">
            <summary>The load configuration table address and size.</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.LoadConfig.#ctor(AlphaOmega.Debug.PEDirectory)">
            <summary>Create instance of LoadConfig class</summary>
            <param name="parent">Data directory</param>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.LoadConfig.Directory32">
            <summary>PE load configuration directory entry</summary>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.LoadConfig.Directory64">
            <summary>PE+ load configuration directory entry</summary>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.USHeap">
            <summary>User string heap class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.Meta.USHeap.#ctor(AlphaOmega.Debug.CorDirectory.MetaData,AlphaOmega.Debug.Cor.STREAM_HEADER)">
            <summary>Create instance of user strings heap class</summary>
            <param name="meta">MetaData directory</param>
            <param name="header">.NET stream header</param>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.USHeap.Item(System.Int32)">
            <summary>Get string from string heap</summary>
            <param name="index">String index in the heap</param>
            <returns>String from heap</returns>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.USHeap.DataString">
            <summary>All strings from heap</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceMessageTable">
            <summary>Resource Message table class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of message table resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.GetMessageBlocks">
            <summary>Получить блоки сообщений</summary>
            <returns>Массив блоков сообщений</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.GetMessageBlockEntries(AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK)">
            <summary>Get all messages from block</summary>
            <param name="block">Message block from witch read all messages</param>
            <returns>Messages array</returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.GetMessageBlockEntries(AlphaOmega.Debug.BytesReader,AlphaOmega.Debug.WinNT.Resource.MESSAGE_RESOURCE_BLOCK)">
            <summary>Get message block entries from starting address</summary>
            <param name="reader">Mapped bytes</param>
            <param name="block">message block header</param>
            <exception cref="T:NotImplementedException">Unknown string encoding specified</exception>
            <returns></returns>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.GetEnumerator">
            <summary>Get all messages from resource directory</summary>
            <returns>Messages array</returns>
        </member>
        <member name="P:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.NumberOfBlocks">
            <summary>Each block contains array of messages</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.MessageResourceEntry">
            <summary>Message descriptor</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.MessageResourceEntry.EntryId">
            <summary>ID of entry that used by eventlog</summary>
        </member>
        <member name="F:AlphaOmega.Debug.NTDirectory.ResourceMessageTable.MessageResourceEntry.EntryName">
            <summary>Message for eventlog</summary>
        </member>
        <member name="T:AlphaOmega.Debug.NTDirectory.ResourceAccelerator">
            <summary>Accelerators class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceAccelerator.#ctor(AlphaOmega.Debug.NTDirectory.ResourceDirectory)">
            <summary>Create instance of accelerators resource class</summary>
            <param name="directory">Resource directory</param>
        </member>
        <member name="M:AlphaOmega.Debug.NTDirectory.ResourceAccelerator.GetEnumerator">
            <summary>Получить список используемых акселераторов</summary>
            <returns>Массив используемых акселераторов</returns>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.StrongNameSignature">
            <summary>.NET Strong name class</summary>
        </member>
        <member name="M:AlphaOmega.Debug.CorDirectory.StrongNameSignature.#ctor(AlphaOmega.Debug.NTDirectory.ComDescriptor)">
            <summary>Create instance of String name hash class</summary>
            <param name="parent">.NET directory</param>
        </member>
        <member name="T:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventRow">
            <summary>
            Events are treated within metadata much like Properties;
            that is, as a way to associate a collection of methods defined on a given class.
            There are two required methods (add_ and remove_) plus an optional one (raise_);
            additonal methods with other names are also permitted (§18).
            All of the methods gathered together as an Event shall be defined on the class (§I.8.11.4).
            </summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventRow.EventFlags">
            <summary>Attributes of an event</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventRow.Name">
            <summary>Event name</summary>
        </member>
        <member name="P:AlphaOmega.Debug.CorDirectory.Meta.Tables.EventRow.EventType">
            <summary>
            An index into a TypeDef, a TypeRef, or TypeSpec table;
            more precisely, a TypeDefOrRef (§II.24.2.6) coded index.
            </summary>
            <remarks>This corresponds to the Type of the Event; it is not the Type that owns this event.</remarks>
        </member>
    </members>
</doc>
